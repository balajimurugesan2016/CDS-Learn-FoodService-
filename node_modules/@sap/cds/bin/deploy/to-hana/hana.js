module.exports = deploy

const fse = require('fs-extra');
const os = require('os');
const path = require('path');

const { BuildTaskEngine, BuildTaskFactory } = require('../../../lib/build');
const buildConstants = require('../../../lib/build/constants');
const cds = require('../../../lib/cds');
const cfUtil = require('./cfUtil');
const { defaultLogger, nullLogger } = require('./logger');
const hdiDeployUtil = require('./hdiDeployUtil');
const mtaUtil = require('../../../lib/utils/mtaUtil');
const runCommand = require('./runCommand');
const { bold } = require('../../utils/term');


const IS_WIN = (os.platform() === 'win32');
const UTF_8 = 'utf-8';
const SERVICE_PLAN = 'hdi-shared';
const PRODUCTION_PROFILE = '[production]';

async function deploy(model, serviceName, noSave, tunnelAddress, buildTaskOptions, credentials, undeployWhitelist, hdiOptions = {}, logger = defaultLogger) { // NOSONAR

  logger.log(`[cds.deploy] - ${bold('Starting deploy to SAP HANA ...')}`);
  logger.log();

  _validateEnvironment();

  const projectPath = path.resolve(process.cwd());

  buildTaskOptions = buildTaskOptions || {
    root: process.cwd()
  };

  let modelPath;
  if (model) {
    logger.log(`[cds.deploy] - Using model from '${bold(model)}'`);
    modelPath = path.resolve(model);
  }

  logger.log(`[cds.deploy] - Creating build tasks`);
  let allTasks;
  const oldDbKind = _getDbKind();
  try {
    // temporarily switch db.kind to 'hana' to make sure a hana build task is created as mtx is only supporting hana
    cds.env.requires.db.kind = "hana";
    const buildTaskFactory = new BuildTaskFactory(nullLogger, cds);
    allTasks = await buildTaskFactory.getTasks(buildTaskOptions);
  } finally {
    cds.env.requires.db.kind = oldDbKind;
  }

  const hanaTasks = allTasks.filter((task => {
    return task.for === buildConstants.BUILD_TASK_HANA && (!modelPath || path.resolve(task.src) === modelPath);
  }));

  if (hanaTasks.length === 0) {
    // const hanaBuildTask = buildTaskFactory._createDbTask(); ??
    // generate hana build task?
    throw new Error(`[cds.deploy] - No 'hana' task found in configuration.`);
  }

  logger.log(`[cds.deploy] - Running build`);
  const buildResults = await new BuildTaskEngine(nullLogger).processTasks(hanaTasks, buildTaskOptions);

  // hana or hanatrial, error if neither found
  const cfServiceName = await _getCfServiceName(logger);

  for (const buildResult of buildResults) {
    const currentModelFolder = buildResult.result.dest;
    const modelName = path.basename(currentModelFolder);

    if (undeployWhitelist) {
      logger.log('[cds.deploy] - Writing undeploy.json');
      await fse.writeJSON(path.join(currentModelFolder, 'undeploy.json'), undeployWhitelist);
    }

    // get from param
    let cfServiceInstanceMta;
    let cfServiceInstanceName;
    if (serviceName) {
      cfServiceInstanceName = serviceName;
    } else {
      cfServiceInstanceMta = await mtaUtil.getHdiService(projectPath, modelName, logger);
      cfServiceInstanceName = cfServiceInstanceMta ? cfServiceInstanceMta.name : mtaUtil.getDefaultHdiServiceName(projectPath, modelName);
    }

    logger.log();
    _validateServiceInstanceName(cfServiceInstanceName);
    logger.log(`[cds.deploy] - Using container ${bold(cfServiceInstanceName)}`);

    let cfConfig = cfServiceInstanceMta && cfServiceInstanceMta.parameters && cfServiceInstanceMta.parameters.config;
    await cfUtil.createService(cfServiceName, SERVICE_PLAN, cfServiceInstanceName, cfConfig, logger);

    let serviceKey;
    if (!credentials) {
      const cfServiceInstanceKey = `${cfServiceInstanceName}-key`;
      serviceKey = await cfUtil.getServiceKey(cfServiceInstanceName, cfServiceInstanceKey, logger);
      if (!serviceKey) {
        throw new Error(`[cds.deploy] - Could not create service key ${bold(cfServiceInstanceKey)}.`);
      }
    } else {
      serviceKey = credentials.hana[0];
    }

    if (tunnelAddress) {
      serviceKey = _injectTunnelAddress(serviceKey, tunnelAddress)
      logger.log(`[cds.deploy] - Using tunnel address ${bold(tunnelAddress)}`);
    }

    let hasJava;
    for (const task of allTasks) {
      switch (task.for) {
        case buildConstants.BUILD_TASK_NODE:
          break;

        case buildConstants.BUILD_TASK_JAVA:
          hasJava = true;
          await _writeConnectionProperties(task.src, serviceKey, logger);
          break;

        default:
          break;
      }
    }

    const defaultEnvJsonPath = path.join(currentModelFolder, 'default-env.json');
    await _writeDefaultEnvJson(defaultEnvJsonPath, cfServiceInstanceName, serviceKey, logger);
    await _addToGitignore(path.join(projectPath, '.gitignore'), 'default-env.json', logger);

    if (hasJava) {
      await _addToGitignore(path.join(projectPath, '.gitignore'), 'connection.properties', logger);
    }

    await _writeDefaultEnvJson(path.join(projectPath, 'default-env.json'), cfServiceInstanceName, serviceKey, logger);

    // Check if deployer is already installed, otherwise only install this one, not the rest of dependencies.
    if (!await hdiDeployUtil.findHdiDeployLib(currentModelFolder, logger)) {
      const { deployerName, deployerVersionSpec } = hdiDeployUtil
      logger.log(`[cds.deploy] - installing ${deployerName}`);
      await runCommand('npm', ['install', `${deployerName}@${deployerVersionSpec}`,
          (noSave ? '--no-save' : '--save-dev')], logger, {
        cwd: currentModelFolder,
        shell: IS_WIN,
        stdio: 'inherit'
      });
    }

    if (!noSave) {
      await _writePackageJson(path.join(projectPath, 'package.json'), modelName, buildResult.task, logger);
    }

    await hdiDeployUtil.deploy(currentModelFolder, _getVCAPEntry(cfServiceInstanceName, serviceKey), hdiOptions, logger);
  }

  logger.log(`[cds.deploy] - Done.`);

  return { buildResults };
}



async function _getCfServiceName(logger) {
  let cfServiceName = 'hana';
  if (!await cfUtil.hasMarketplaceService(cfServiceName, SERVICE_PLAN, logger)) {
    cfServiceName = 'hanatrial';
    if (!await cfUtil.hasMarketplaceService(cfServiceName, SERVICE_PLAN, logger)) {
      throw new Error('[cds.deploy] - Services not found');
    }
  }

  return cfServiceName;
}


async function _writeDefaultEnvJson(defaultEnvJsonPath, serviceInstanceName, serviceKey, logger) {
  let defaultEnvJson = {};
  if (await fse.pathExists(defaultEnvJsonPath)) {
    defaultEnvJson = await fse.readJSON(defaultEnvJsonPath, UTF_8);
  }

  defaultEnvJson.VCAP_SERVICES = defaultEnvJson.VCAP_SERVICES || {};
  defaultEnvJson.VCAP_SERVICES.hana = defaultEnvJson.VCAP_SERVICES.hana || [];
  defaultEnvJson.VCAP_SERVICES.hana = defaultEnvJson.VCAP_SERVICES.hana.filter(entry => {
    return entry.name !== serviceInstanceName;
  });

  defaultEnvJson.VCAP_SERVICES.hana.push(_getVCAPEntry(serviceInstanceName, serviceKey));

  logger.log(`[cds.deploy] - Writing ${defaultEnvJsonPath}`);
  await fse.outputJSON(defaultEnvJsonPath, defaultEnvJson, {
    spaces: 2
  });
}


async function _writeConnectionProperties(javaModulePath, serviceKey, logger) {

  const connectionPropertiesPath = path.join(javaModulePath, 'src', 'main', 'resources', 'connection.properties');

  const content = `#Db connection properties created by cds deploy
schema=${serviceKey.schema}
username=${serviceKey.user}
password=${serviceKey.password}
connectionURL=${serviceKey.url.replace(/=/g, '\\=')}
`;

  logger.log(`[cds.deploy] - Writing ${connectionPropertiesPath}`);
  await fse.outputFile(connectionPropertiesPath, content);
}


async function _addToGitignore(gitIgnorePath, entry, logger) {
  let gitignore = '';
  if (await fse.pathExists(gitIgnorePath)) {
    gitignore = await fse.readFile(gitIgnorePath, UTF_8);
  }

  const entries = gitignore.split(os.EOL);
  if (!entries.includes(entry)) {
    logger.log(`[cds.deploy] - Adding ${entry} to ${gitIgnorePath}`);
    gitignore = gitignore + `\n${entry}\n`;
    await fse.outputFile(gitIgnorePath, gitignore);
  }
}


function _validateEnvironment() {
  if (IS_WIN && !process.env.SECUDIR) {
    throw new Error(`[cds.deploy] - In order to use the hdi deployer for Windows you require the SAP CommonCryptoLib.
Please follow https://help.sap.com/viewer/e54136ab6a4a43e6a370265bf0a2d744/4.2.12/en-US/c049e28431ee4e8280cd6f5d1a8937d8.html for further information.`);
  }
}


function _getVCAPEntry(serviceInstanceName, serviceKey) {
  return {
    name: serviceInstanceName,
    tags: ['hana'],
    credentials: serviceKey
  };
}


async function _writePackageJson(packageJsonPath, modelName, task, logger) {
  if (await fse.pathExists(packageJsonPath)) {
    const packageJson = await fse.readJSON(packageJsonPath, UTF_8);

    if (!packageJson.dependencies || !packageJson.dependencies.hdb) {
      const hdbVersion = await _getHDBVersion();
      packageJson.dependencies = packageJson.dependencies || {};
      packageJson.dependencies.hdb = `^${hdbVersion}`;
    }

    packageJson.cds = packageJson.cds || {};
    packageJson.cds.requires = packageJson.cds.requires || {};
    packageJson.cds.requires[modelName] = packageJson.cds.requires[modelName] || {};

    if (packageJson.cds.requires[modelName].kind !== 'hana') {
      packageJson.cds.requires[modelName][PRODUCTION_PROFILE] = packageJson.cds.requires[modelName][PRODUCTION_PROFILE] || {};
      packageJson.cds.requires[modelName][PRODUCTION_PROFILE].kind = 'hana';
      // only fill the hana model if it's not yet set and only if there is no default model
      if (!packageJson.cds.requires[modelName][PRODUCTION_PROFILE].model && !packageJson.cds.requires[modelName].model) {
        packageJson.cds.requires[modelName][PRODUCTION_PROFILE].model = task.options.model;
      }

      logger.log(`[cds.deploy] - Writing ${packageJsonPath}`);
      await fse.outputJSON(packageJsonPath, packageJson, { spaces: 2 });
    }
  }
}

async function _getHDBVersion() {
  const cmdResult = await runCommand('npm', ['show', 'hdb', 'version'], nullLogger, {
    shell: IS_WIN
  });
  return cmdResult.stdout.trim();
}

function _validateServiceInstanceName(serviceInstanceName) {
  // valid service name chars: alpha-numeric, hyphens, and underscores
  if (/[^\w\d-_]+/g.exec(serviceInstanceName)) {
    throw new Error(`[cds.deploy] - Service name ${serviceInstanceName} must only contain alpha-numeric, hyphens, and underscores.`);
  }
}

function _getDbKind() {
  cds.env = cds.env || {};
  cds.env.requires = cds.env.requires || {};
  cds.env.requires.db = cds.env.requires.db || {};
  return cds.env.requires.db.kind;
}

function _injectTunnelAddress(serviceKey, tunnelAddress) {
  if (!/\w+:\d+/.test(tunnelAddress)) {
    throw new Error(`Invalid tunnel address '${tunnelAddress}' - must be in form 'host:port'`)
  }
  const [tunnelHost, tunnelPort] = tunnelAddress.split(':')
  const {host, port} = serviceKey
  serviceKey.host = tunnelHost
  serviceKey.port = tunnelPort
  serviceKey.url = serviceKey.url.replace(`${host}:${port}`, tunnelAddress)
  serviceKey.hostname_in_certificate = host  // make cert. verification happy, see xs2/hdideploy.js#527
  return serviceKey
}
