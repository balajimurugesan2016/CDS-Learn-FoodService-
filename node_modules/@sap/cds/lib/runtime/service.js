const cds = require ('../cds')
const fs = require ('../utils/fs')
const lib = require('@sap/cds-services'); lib.inject(cds)

/**
 * Decorate cds.service
 */

 module.exports = Object.assign ({__proto__:cds.builtin.classes.service}, {
    impl : fn=>fn,
    client : { for: lib.for },
    provider : { for: service_provider_for },
    adapter : { for: Object.assign (lib.to, {
        odata : lib.to.odata_v4,
        fiori : lib.to.odata_v4,
    }) },
    providers : [],
    passport : lib.passport,
    performanceMeasurement : lib.performanceMeasurement,
    path4 : path4,
    impl4 : impl4,
    bindings :  require('./bindings')
})



function service_provider_for (def, /*in:*/ csn, options) {

    const service = def.name, at = path4 (def, options.at)
    const provider = lib.service (csn, { ...options, at, service })
    provider.path = at

    // adding convenience methods ...
    provider.on.succeeded = (event, entity, handler) => {
        if (!handler) [entity,handler] = [undefined,entity]
        return provider.on (event,entity, (req)=>{
            req.on('succeeded', ()=>handler(req))
        })
    }
    provider.on.failed = (event, entity, handler) => {
        if (!handler) [entity,handler] = [undefined,entity]
        return provider.on (event,entity, req=>{
            req.on('failed', ()=>handler(req))
        })
    }
    provider.on.resultsOf = (...args) => provider.after (...args)
    return provider
}



const {dirname,parse,resolve} = require('path')
const {isdir} = cds.utils

/**
 * Resolve a service implementation function as follows...
 * 1. if _impl is a function --> got it
 * 2. if _impl is a string --> `require (it)` (using model source if available)
 * 3. if we got the model's source --> `require (<basename>.js) || require (js/<basename>.js) || require (handlers/<basename>.js)`
 */
function impl4 (def, _impl = def['@impl'], cwd=process.cwd()) { // NOSONAR
    const dirs = new Set([cwd])

    // add model's neighbourhood to search paths (@source has precedence over $location as the latter refers to csn file if loaded from csn.json)
    const _source = def['@source']
    if (_source && isdir(dirname(_source)))  dirs.add(dirname(_source))
    const _location = def.$location && def.$location.file
    if (_location && isdir(dirname(_location)))  dirs.add(dirname(_location))

    // resolve handler from @impl annotation - fail if not exist
    if (typeof _impl === 'function')  return _found (_impl)
    if (_impl)  return _load (_impl, true)

    // try to resolve handler based on .cds file name - ignore if not exist
    if (_source || _location) {
        const impl = parse(_source || _location).name + '.js'
        return _load(impl) || _load('js/'+impl) || _load('handlers/'+impl)
    }

    function _found (impl, _source = impl.name || '<inline>') {
        return Object.defineProperty (impl, '_source', {value:_source})
    }

    function _load (file, fail=false) {
        if (!file.endsWith('.js'))  file += '.js'
        for (let each of dirs) {
            const resolved = resolve (each,file)
            if (fs.isfile (resolved))  return _found (require (resolved), resolved)
        }
        if (fail)  throw new Error(`No such handler for ${def.name}: ${file}`)
    }
}

/**
 * Resolve a service endpoint path to mount it to as follows...
 * Use _path or def[@path] if given with leading '/' prepended if necessary.
 * Otherwise, use the service definition name with stripped 'Service'
 */
function path4 (def, _path = def['@path']) {
  if (_path)  return _path.replace(/^[^/]/, c => '/'+c)
  else  return '/' + ( // generate one from the service's name
    /[^.]+$/.exec(def.name)[0]  //> my.very.CatalogService --> CatalogService
    .replace(/Service$/, '')        //> CatalogService --> Catalog
    .replace(/^[A-Z]/, c => c.toLowerCase())  //> Catalog --> catalog
    .replace(/[A-Z][a-z]/g, c => '-'+c.toLowerCase())  //> FooBar --> foo-bar
    .replace(/[A-Z]/g, c => c.toLowerCase())  //> FOO --> foo
    .replace(/_/g,'-')  //> foo_bar --> foo-bar
  )
}
