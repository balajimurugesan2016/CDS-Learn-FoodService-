const cds = require('../cds'), lib = require('@sap/cds-ql'); lib.inject(cds)

// FIXME: we currently cannot use standard subclassing due to  singleton.js
// and weird and test setups in cds-ql/services
exports.Service = function (ds,o, ___primary) {
    const srv = lib.connect.connect (ds,o, ___primary || o.primary || ds === 'db')
    if (ds) srv.name = ds //> should be done in new Session
    return srv
}
const {disconnect} = lib.Service.prototype
cds.extend (lib.Service.prototype) .with (class {

    // only for compat to cds-ql impl --> add console.trace() to find the parts to fix
    set entities(_ignored) {}
    set types(_ignored) {}

    get entities() {
        return this.model.childrenOf (this, x=>x.is('entity'), 'entities')
    }

    get types() {
        return this.model.childrenOf (this, x=>x.is('type'), 'services')
    }

    disconnect() {
        cds.emit('disconnect', this)
        return disconnect.call(this)
    }

    on(){} // interims workaround
    emit(){} // interims workaround

})



exports.Promised = function (srv, promise) {
    if (!promise) {
        // let promise = Promise.resolve(srv)
        // return {__proto__:srv,
        //     then:(r,e) => promise = promise.then(r,e),
        //     catch:(e) => promise = promise.catch(e),
        // }
        return _ready (srv, {__proto__:srv,
            then:(r) => r(srv),
            catch:() => {},
        })
    } else {
        return _ready (srv, {__proto__:srv,
            // then:(r,e) => promise = promise.then(()=>{ if (srv.name) cds.services[srv.name] = srv; return r(srv) },e),
            then:(r,e) => promise = promise.then(()=>r(srv),e),
            catch:(e) => promise = promise.catch(e),
            on: Object.assign ((..._) => promise.then (()=>srv.on(..._)), {
                succeeded: (..._) => promise.then (()=>srv.on.succeeded(..._)),
                failed: (..._) => promise.then (()=>srv.on.failed(..._)),
                resultsOf: (..._) => promise.then (()=>srv.on.resultsOf(..._)),
            }),
            before: (..._) => promise.then (()=>srv.before(..._)),
            after: (..._) => promise.then (()=>srv.after(..._)),
            run: (..._) => promise.then (()=>srv.run(..._)),
            stream: (..._) => promise.then (()=>srv.stream(..._)),
            foreach: (..._) => promise.then (()=>srv.foreach(..._)),
        })
    }
}

function _ready (srv, promised) {
    Object.defineProperty (srv, '_ready', {value:promised,
        configurable:true  	// FIXME: this should not be neccessary --> is likely due to ql.connect.connect singleton!
    })
    return promised
}
