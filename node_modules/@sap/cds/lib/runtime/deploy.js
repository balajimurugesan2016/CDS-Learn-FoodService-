const DEBUG = /\b(y|all|deploy)\b/.test (process.env.DEBUG) && console.warn // eslint-disable-line
const cds = require('../../lib/cds')
const cwd = process.cwd()

module.exports = function cds_deploy (model = ['db','srv']) { return {
    async to (db, options) {

      if (typeof db === 'string')  db = await cds.connect.to (db,options)
      if (typeof model === 'string')  model = await cds.load (model)
      else if (Array.isArray(model))  model = await cds.load (model)

      await db.deploy (model)

      if (!cds.db)  cds.db = db
      if (!db.model) {
        db.options.model = model._sources || '<dynamic model>'
        // db.model = cds.linked (model)
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        // FIXME: This is horribly ugly, but required to avoid even more ugly hacks in the runtime lib's model handling to kick in
          // db.model['@sql_mapping'] = true //cds.compile.for.odata (model)
          // FIXME: even worse, we need this because of drafts
          db.model = cds.linked (cds.compile.for.odata (model))
        ///////////////////////////////////////////////////////////////////////////////////////////////////////
        require('../alpha/_localized') .connect (db.model)
      }

      // fill in initial data...
      const SILENT = options && options.silent || process.env.NODE_ENV === 'test'
      await init_from_js (db,model,SILENT)
      await init_from_csv (db,model,SILENT)

      return db
    },
    // continue to support cds.deploy() as well...
    then(n,e) { return this.to (cds.db) .then (n,e) },
    catch(e) { return this.to (cds.db) .catch (e) },
}}


const csvs = filename => filename[0] !== '-' && filename.endsWith ('.csv')
const { path, isdir, isfile, readdir, readFile } = cds.utils

function init_from_js (db, csn, SILENT) {

  if (!csn._sources)  return
  const folders = new Set([ path.resolve('db'), ...csn._sources.map (path.dirname)])
  const inits = []

  for (let each of folders) {
    const file = isfile (path.resolve(each,'init.js'));  if (!file)  continue
    SILENT || console.log (` > initializing database from ${path.relative(cwd,file)}`)  // eslint-disable-line
    let init = require(file);  if (!init)  continue
    if (!init.then && typeof init === 'function')  inits.push (db.run(()=> init(db)))
    else  inits.push (init)
  }

  return Promise.all (inits)
}


function init_from_csv (db, csn, SILENT) { // NOSONAR

  if (!csn._sources)  return
  const folders = new Set
  for (let model of csn._sources) {
    for (let each of [ model+'/../init.js', 'db/init.js' ]) {
        if (isfile (path.resolve(each))) continue
    }
    for (let data of ['/data','/csv']) {
      for (let each of [ model+data, model+'/..'+data ]) {
        let folder = path.resolve (each)
        if (isdir (folder))  folders.add(folder)
      }
    }
  }

  if (folders.size > 0)  return db.acquire() .then (tx => tx.begin()
    .then (()=> Promise.all ([...folders].map (folder => _init (folder,tx))))
    .then (()=> tx.commit())
    .then (()=> db.release (tx))
  )

  function _init (folder, tx) { return new Promise (_done => {
    let n=0;
    readdir (folder, (e,files) => {
      _error(e)

      const csvFiles = files.filter(csvs)
      if(csvFiles.length < 1) {
        return _done()
      }

      csvFiles.forEach (each => {
        let entity = _entity4 (each.replace(/-/g,'.').slice(0,-4));  if (!entity) {
          DEBUG && DEBUG (` - warning: ${each} not in model`)  // eslint-disable-line
          return _done()
        }
        let file = path.join(folder,each)
        ++n; readFile (file, 'utf8', (e,src)=>{ _error(e)
          SILENT || console.log (` > filling ${entity.name} from ${path.relative(cwd,file)}`)  // eslint-disable-line
          let [ cols, ...rows ] = cds.parse.csv (src)
          let insert = INSERT.into (entity) .columns (cols) .rows (rows) /* global INSERT */
          tx.run (insert) .then (()=> --n || _done())
        })
    })})
  })}

  function _entity4 (name) {
      const entity = csn.definitions [name]
      if (!entity) {
        if (name.endsWith('_texts')) {
            const base = csn.definitions [name.slice(0,-6)]
            if (base)  return _entity4 (base.elements.texts.target)
        }
        return
      }
      if (entity.query) {
        let {SELECT} = entity.query
        if (SELECT && !SELECT.columns && SELECT.from.ref && SELECT.from.ref.length === 1) {
            return csn.definitions [SELECT.from.ref[0]]
        }
      }
      return entity
  }

  function _error(e) {
    if (e)  throw e
  }

}
