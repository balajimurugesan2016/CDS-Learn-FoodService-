module.exports = Object.assign (cds_serve, { addImplsFor:_addServiceImpls })
const cds = require ('../cds')
const cache = cds_serve.cache = {}

const ProtocolAdapter = {for:(srv, to='odata_v4') => {
  if (srv._adapters) {
    const a = srv._adapters[to];  if (a) return a
  } else {
    Object.defineProperty (srv,'_adapters', {value:{}})
  }
  const adapter4 = cds.service.adapter.for[to]
  if (adapter4)  return srv._adapters[to] = adapter4(srv)
  else throw new Error (`service protocol ${to} is not supported`)
}}


const _unfold_localized = require('../alpha/_localized').serve

/**
 * Load given model(s) and construct providers for all defined services.
 */
function cds_serve (service_or_model, _options) { // NOSONAR

  if (Array.isArray(service_or_model) && service_or_model.length === 1)
    service_or_model = service_or_model[0]

  if (!isIdentifier(service_or_model)) {
    (_options || (_options={})) .from = service_or_model
    service_or_model = 'all'
  }

  cds.ql.disable_cds_run()

  // Prepare fluent API to fill in options...
  const o = {..._options}, fluent = {
    from (model) { o.from = model; return this },
    to (protocol) { if (protocol) { o.to = protocol }  return this },
    at (path) { if (path) { o.at = path }  return this },
    with (impl) { if (impl) { o.with = impl }  return this },
    // ... and to finalize our job:
    in (app) { ready.then (ps => _addProviders2(app,ps,o)); return this },
    then (r,e) { return ready.then (ps => r(_returnProviders(ps,o)), e) },
    catch (e) { return ready.catch(e) },
  }

  // We start with a Promise.resolve() to first fill options fluently
  const ready = Promise.resolve() .then (()=> Promise.all ([
    _loadModel(service_or_model,o),
    cds.service.bindings.import()
  ])) .then (([csn])=> _constructProviders (csn,o))

  return fluent
}


function isIdentifier (x) {
  // if (x === 'srv' || x === 'app')  return false
  return typeof x === 'string' && /^[\w$]*$/.test (x)
}


/**
 * Load the given model if it's not already a parsed csn passed in
 */
function _loadModel (service_or_model, o) {

  let model

  //> cds.serve(...).from('app')
  if (o.from) {
    model = o.from
    o.service = service_or_model
  }

  if (!model) model = o.from

  //> cds.serve(...).from(csn)
  if (typeof model === 'object' && !Array.isArray(model))
    return model

  //> cds.serve(...)
  if (!model) {
    //> cds.serve(..., {service})  ==>  cds.serve(service) .from (...)
    //> Note: this is for compatibility only; it's not documented anymore
    if (o.service)  model = service_or_model

    //> cds.serve('all')  ==>  cds.serve('all').from('all')
    //> cds.serve(service)  ==>  cds.serve(service).from('all')
    else { model = 'all'; o.service = service_or_model }
  }

  if (model === 'all' || model[0] === 'all') {
    const {app,srv} = cds.env.folders
    model = [ app, srv, 'services', '.' ].find (m => cds.resolve(m))
    if (!model)  throw new Error (`[cds] - \n
      No service models found in current working directory.
      Make sure you call cds.serve in the root of your project.
    `)
  }

  const key = Array.isArray(model) ? model.join(';') : model
  const cached = cache[key]
  if (cached) return cached

  return cache[key] = cds.load (model)
}


/**
 * Construct providers for all services defined in the loaded model.
 */
function _constructProviders (csn, o, n=0) {

  const providers = []
  const required = cds.env.requires
  const _include = o.service && o.service !== 'all'
    ?  (def) => def.name.endsWith (o.service)
    :  ()=> true
  const _exclude = (def) => {
    if (o.mocked && def.name in cds.services)  return true // skip already served ones
    if (def['@cds.ignore'] || def['@cds.serve.ignore'])  return true // exclude
    if (def['@external'] && !o.mocked)  return true // exclude
    const {credentials} = required[def.name] || {}
    if (!credentials)  return // do not exclude
    const {url,destination,whatever} = credentials
    if (url || destination || whatever)  return true // exclude
  }

  if (!cds.services.skipped)  cds.services.skipped = []
  const {requires:{db}} = cds.env, ad_hoc = cds.options
  const is_sqlite = db && db.kind === 'sqlite'  ||  ad_hoc && ad_hoc.kind === 'sqlite'
  cds.reflect(csn) .foreach (cds.service, def => {
    if (!_include(def) || _exclude(def))  return cds.services.skipped.push ({ service:def.name, csn })  // might be mocked afterward
    if ((o.at || o.with) && ++n > 1) throw new Error('You cannot specify `path` or `impl` for multiple services')
    if (is_sqlite)  _unfold_localized (csn)
    const provider = cds.service.provider.for (def, csn, o)
    if (is_sqlite)  _unfold_localized (provider.model) // REVISIT: this is because provider._csn = provider.model
    cds.services [def.name] = provider
    if (!cds.service.providers.includes(provider)) // REVISIT: only required unless we cleaned up cds-services to not do that
      cds.service.providers.push (provider)
    providers.push (provider)
    PATCH_dispatch (provider)
  })

  if (!o.mocked && !o['with-mocks'])  _addServiceImpls (providers,o)

  return providers
}

/**
 * Invoke all provided service implementation functions or classes.
 * IMPORTANT: this is run in a second pass after all providers are
 * constructed and registered so implementations can connect to
 * each others.
 */
function _addServiceImpls (providers, o) {
  for (let each of providers) {
    const _impl = each._impl = cds.service.impl4 (each.definition, o && o.with)
    if (_impl)  each.impl (_impl)
  }
}

/**
 * Add constructed providers to express app
 */
function _addProviders2 (app,providers,o) {
  if (providers.length == 0)  return providers
  for (let each of providers) {
    // audit logger to be provided here, current workaround: take it from service
    cds.service.performanceMeasurement(app)
    cds.service.passport(each, app, each._auditLogger, o)
    // add use method to services for backward compatibility
    each.use = app.use
    app.use (each.path, ProtocolAdapter.for (each, o.to))
    cds.emit ('serve', each)
  }
  cds.emit ('served', { model:providers[0].model, app })
  return providers
}

/**
 * Returns a single picked provider or a map of all constructed providers
 */
function _returnProviders (providers,o) {
  if (providers.length === 0)  return
  let all={}, srv='none'
  for (let each of providers) {
    srv = all[each.name] = _asHandlerFunction (each,o)
  }
  if (providers.length === 1 && srv.name.endsWith(o.service) >= 0) { // NOSONAR
    if (!(srv.name in srv))  Object.assign (srv,all)  // NOSONAR
    return srv
  }
  else return all
}

/**
 * Decorates services as handler functions to delegate requests to the default protocol adapter.
 * This supports usages like this:
 * @example
 * const { CatalogService } = cds.serve(...)
 * app.use ('/cats', CatalogService)
 */
function _asHandlerFunction (srv,o) {
    const adapter = ProtocolAdapter.for (srv, o.to)
    const fn = (...args) => adapter(...args)
    Object.setPrototypeOf (fn, srv)
    Object.defineProperty (fn, 'name', {value:srv.name})
    return fn
}

function PATCH_dispatch (provider) {
  const {processEvent:dispatch} = provider
  provider.dispatch = provider.processEvent = (req, ...etc) => {
    if (req._.req) {
      req._.path = req._.odataReq ? req._.odataReq._url.pathname : req._.req.path
      req._.query = req._.odataReq ? req._.odataReq._queryOptions : req._.query
      req._.req.emit ('dispatch', req)
    }
    return dispatch.call (provider, req, ...etc)
  }
}
