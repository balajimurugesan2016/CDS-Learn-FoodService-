const { all } = require('../util/thenable')
const generateUUID = require('uuid/v4')
const getAnnotatedElements = require('../adapter/utils/getAnnotatedElements')

const processDeep = (callbackFn, data, entity, skipRoot, isRoot) => {
  if (!Array.isArray(data)) {
    processDeep(callbackFn, [data], entity, skipRoot, isRoot)
    return
  }
  data.forEach(entry => {
    if (!(skipRoot && isRoot)) {
      callbackFn(entry, entity, isRoot)
    }

    Object.keys(entity.elements || {}).forEach(key => {
      const element = entity.elements[key]

      if (element.type === 'cds.Composition' && entry[element.name]) {
        const subData = Array.isArray(entry[element.name]) ? entry[element.name] : [entry[element.name]]
        processDeep(callbackFn, subData, element._target, false, false)
      }
    })
  })
}

const _deeperElements = (callbackFn, entry, elements = {}) => {
  return Object.keys(elements).map(async key => {
    const element = elements[key]

    if (element.type === 'cds.Composition' && entry[element.name]) {
      const subData = Array.isArray(entry[element.name]) ? entry[element.name] : [entry[element.name]]

      return processDeepAsync(callbackFn, subData, element._target, false, false)
    }
  })
}

const processDeepAsync = async (callbackFn, data, entity, skipRoot, isRoot) => {
  if (!Array.isArray(data)) {
    return processDeepAsync(callbackFn, [data], entity, skipRoot, isRoot)
  }

  const deep = data.map(async entry => {
    if (!(skipRoot && isRoot)) {
      await callbackFn(entry, entity, isRoot)
    }

    return all(_deeperElements(callbackFn, entry, entity.elements))
  })

  return all(deep)
}

const _getAnnotatedColumns = (method, target, user, date) => {
  switch (method) {
    case 'POST':
      return getAnnotatedElements('insert', target, user, date)
    case 'PUT':
    case 'PATCH':
      return getAnnotatedElements('update', target, user, date)
    default:
      return []
  }
}

const _fillAnnotatedValues = (annotatedColumns, data) => {
  for (const column of annotatedColumns) {
    data[column.name] = column.value
  }
}

/**
 * This method adds default values and annotated values to data for elements not having default values, also adds UUID keys if not given.
 * @private
 */
const fillData = (data, entity, method, user, date) => {
  const elements = entity.elements

  const annotatedColumns = _getAnnotatedColumns(method, entity, user, date)
  _fillAnnotatedValues(annotatedColumns, data)

  for (const column of Object.keys(elements)) {
    const col = elements[column]

    if (col.key && col.type === 'cds.UUID' && data[column] === undefined) {
      data[column] = generateUUID()
    } else if (method !== 'PATCH' && col.default !== undefined && data[col.name] === undefined) {
      data[col.name] = 'val' in col.default ? col.default.val : col.default // OLD CSN
    }
  }
}

const fillDataDeep = (data, entity, method, user, date = new Date()) => {
  processDeep(
    (data, entity) => {
      fillData(data, entity, method, user, date)
    },
    data,
    entity,
    false
  )
}

module.exports = {
  processDeep,
  processDeepAsync,
  fillData,
  fillDataDeep
}
