const { DRAFT_COLUMNS } = require('./constants')

const _findCorrespondingEntryWithSameKeys = (source, entry, keys) => {
  return source.find(sourceEntry => keys.every(key => sourceEntry[key] === entry[key]))
}

const _diffCreate = (entity, entry, keys) => {
  const diffs = []

  diffs.push(
    Object.keys(entry).reduce(
      (prev, curr) => {
        if (DRAFT_COLUMNS.includes(curr)) {
          return prev
        }

        if (entity.elements[curr].type === 'cds.Composition') {
          diffs.push(...compareJson(entry[curr], [], entity.elements[curr]._target))
        } else if (keys.includes(curr)) {
          prev.keys[curr] = entry[curr]
        } else {
          prev.values = prev.values || {}
          prev.values[curr] = { new: entry[curr] }
        }

        return prev
      },
      { type: 'create', entity: entity.name, keys: {} }
    )
  )

  return diffs
}

const _diffDelete = (entity, entry, keys) => {
  const diffs = []

  diffs.push(
    Object.keys(entry).reduce(
      (prev, curr) => {
        if (DRAFT_COLUMNS.includes(curr)) {
          return prev
        }

        if (entity.elements[curr].type === 'cds.Composition') {
          diffs.push(...compareJson([], entry[curr], entity.elements[curr]._target))
        } else if (keys.includes(curr)) {
          prev.keys[curr] = entry[curr]
        } else {
          prev.values = prev.values || {}
          prev.values[curr] = { old: entry[curr] }
        }

        return prev
      },
      { type: 'delete', entity: entity.name, keys: {} }
    )
  )

  return diffs
}

const _diffUpdate = (entity, newEntry, oldEntry, keys) => {
  const diffs = []

  diffs.push(
    Object.keys(oldEntry).reduce(
      (prev, curr) => {
        if (DRAFT_COLUMNS.includes(curr)) {
          return prev
        }

        if (entity.elements[curr].type === 'cds.Composition') {
          const normalizedNewEntry = newEntry[curr] !== undefined ? newEntry[curr] : []
          diffs.push(...compareJson(normalizedNewEntry, oldEntry[curr], entity.elements[curr]._target))
        } else if (keys.includes(curr)) {
          prev.keys[curr] = oldEntry[curr]
          // add value only if present in oldEntry and newEntry because we always treat as patch
        } else if (newEntry[curr] !== undefined && oldEntry[curr] !== newEntry[curr]) {
          prev.values = prev.values || {}
          prev.values[curr] = { old: oldEntry[curr], new: newEntry[curr] }
        }

        return prev
      },
      { type: 'update', entity: entity.name, keys: {} }
    )
  )

  // find new compositions
  for (const key of Object.keys(newEntry)) {
    if (entity.elements[key].type === 'cds.Composition' && oldEntry[key] === undefined) {
      diffs.push(...compareJson(newEntry[key], [], entity.elements[key]._target))
    }
  }

  return diffs
}

/**
 * Compares newState and oldState to find all differences.
 * Respects all compositions.
 *
 * Output format is:
 * {
 *  type: 'update',
 *  entity: 'entityName',
 *  keys: { ID: 1 },
 *  values: {
 *    old: 'A',
 *    new: 'B'
 *   }
 * }
 *
 * @example
 * compareJson([{ID: 1, col1: 'A'}], [{ID: 1, col1: 'B'}], csnEntity)
 *
 * @param {Array|Object} newState
 * @param {Array|Object} oldState
 * @param {Object} entity
 *
 * @return {Array}
 */
const compareJson = (newState, oldState, entity) => {
  const result = []
  const keys = Object.keys(entity.keys).filter(
    key =>
      !DRAFT_COLUMNS.includes(key) &&
      entity.elements[key].type !== 'cds.Composition' &&
      entity.elements[key].type !== 'cds.Association'
  )

  // normalize to array for composition to one
  const oldData = Array.isArray(oldState) ? oldState : [oldState]
  const newData = Array.isArray(newState) ? newState : [newState]

  // add deletes and updates
  for (const oldEntry of oldData) {
    const entry = _findCorrespondingEntryWithSameKeys(newData, oldEntry, keys)

    if (entry) {
      const diffs = _diffUpdate(entity, entry, oldEntry, keys)

      // find actual updates or create/delete in a composition containing only the keys
      result.push(...diffs.filter(diff => (diff.type === 'update' && diff.values) || diff.type !== 'update'))
    } else {
      result.push(..._diffDelete(entity, oldEntry, keys))
    }
  }

  // add creates
  for (const newEntry of newData) {
    if (!_findCorrespondingEntryWithSameKeys(oldData, newEntry, keys)) {
      result.push(..._diffCreate(entity, newEntry, keys))
    }
  }

  return result
}

module.exports = compareJson
