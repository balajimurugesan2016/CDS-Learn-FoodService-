const _backLinkCustom = (name, target, element, entityKeys) => {
  const backlink = {
    name: name.startsWith(`${element.name}.`) ? name.replace(`${element.name}.`, '') : name,
    target_element: target.startsWith(`${element.name}.`) ? target.replace(`${element.name}.`, '') : target
  }

  if (entityKeys && entityKeys.some(key => name === `${element.target}.${key}`)) {
    return { name: backlink.target_element, target_element: backlink.name }
  }

  if (entityKeys && entityKeys.some(key => name === `${element.name}_${key}`)) {
    return backlink
  }

  if (target.startsWith(`${element.name}.`)) {
    return { name: backlink.target_element, target_element: backlink.name }
  }

  return backlink
}

const _backlinkForCustomOn = (element, entityKeys) => {
  const { name, target } = _onElements(element)
  return _backLinkCustom(name, target, element, entityKeys)
}

const _backlinkForCustomOnCond = (element, entityKeys) => {
  const { name, target } = _onCondElements(element)
  return _backLinkCustom(name, target, element, entityKeys)
}

const _backlinkName = (onCondElement1, onCondElement2) => {
  return onCondElement1 === '$self' ? onCondElement2 : onCondElement1
}

const _backLinkNameFromOn = element => {
  const onCondElement1 = element.on[0].ref.length === 2 ? element.on[0].ref[1] : element.on[0].ref[0]
  const onCondElement2 = element.on[2].ref.length === 2 ? element.on[2].ref[1] : element.on[2].ref[0]

  return _backlinkName(onCondElement1, onCondElement2)
}

const _cleanupOnCondElement = (element, onCondElement) => {
  return onCondElement.startsWith(`${element.name}.`) ? onCondElement.replace(`${element.name}.`, '') : onCondElement
}

const _onElements = element => {
  const name = element.on[2].ref.join('.')
  const target = element.on[0].ref.join('.')

  return { name, target }
}

const _onCondElements = element => {
  const name = element.onCond.args[1]['=']
  const target = element.onCond.args[0]['=']

  return { name, target }
}

const getOnCondElements = element => {
  if (element.on) {
    return _onElements(element)
  } else if (element.onCond && element.onCond.op === '=') {
    return _onCondElements(element)
  }
}

const _backLinkNameFromOnCond = element => {
  const onCondElement1 = _cleanupOnCondElement(element, element.onCond.args[0]['='])
  const onCondElement2 = _cleanupOnCondElement(element, element.onCond.args[1]['='])

  return _backlinkName(onCondElement1, onCondElement2)
}

const _isSelfManagedOn = on => {
  if (on.length > 2) {
    return on[0].ref[0] === '$self' || on[2].ref[0] === '$self'
  }

  return false
}

const _isSelfManagedOnCond = onCond => {
  if (onCond.args.length > 1) {
    return onCond.args[0]['='] === '$self' || onCond.args[1]['='] === '$self'
  }

  return false
}

const isSelfManaged = onCond => {
  if (onCond.on) {
    return _isSelfManagedOn(onCond.on)
  } else if (onCond.onCond) {
    // should not be null/undefined
    return _isSelfManagedOnCond(onCond.onCond)
  }
}

const getBackLinks = (element, entityKeys) => {
  const backLinks = []
  let prefix

  if (element.on) {
    if (_isSelfManagedOn(element.on)) {
      prefix = _backLinkNameFromOn(element)
    } else {
      return [_backlinkForCustomOn(element, entityKeys)]
    }
  } else if (element.onCond && element.onCond.op === '=') {
    if (_isSelfManagedOnCond(element.onCond)) {
      prefix = _backLinkNameFromOnCond(element)
    } else {
      return [_backlinkForCustomOnCond(element, entityKeys)]
    }
  } else {
    prefix = element.name
  }

  for (const entityKey of entityKeys) {
    if (entityKey === 'IsActiveEntity') {
      continue
    }
    backLinks.push({ name: `${prefix}_${entityKey}`, target_element: entityKey })
  }
  return backLinks
}

module.exports = {
  getBackLinks,
  isSelfManaged,
  getOnCondElements
}
