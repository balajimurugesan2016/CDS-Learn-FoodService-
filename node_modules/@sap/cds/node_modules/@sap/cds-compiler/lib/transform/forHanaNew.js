"use strict";
var { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { setProp } = require('../base/model');
const {
  mergeOptions, hasBoolAnnotation, getTopLevelArtifactNameOf,
  getElementDatabaseNameOf } = require('../model/modelUtils.js');
const { getUtils, cloneCsn, forEachGeneric, 
        forEachDefinition, forEachMember, 
        forEachMemberRecursively, forEachRef,
        forAllQueries
      } = require('../model/csnUtils');
const transformUtils = require('./transformUtilsNew');
const { checkTypeParameters } = require('../checks/checkElements');
const alerts = require('../base/alerts');
const { translateAssocsToJoins } = require('./translateAssocsToJoins');
const csnRefs = require('../model/csnRefs');

/**
 * If a mixin association is published, return the mixin association.
 *
 * @param {any} query Query of the artifact to check
 * @param {Element} association Association published by the view
 * @returns {Object} The mixin association
 */
function getMixinAssocOfQueryIfPublished(query, association, associationName) {
  if (query && query.SELECT && query.SELECT.mixin) {
    for (let elem of Object.keys(query.SELECT.mixin)) {
      const mixin_element = query.SELECT.mixin[elem];
      if (elem === associationName && mixin_element.target === association.target) {
        return mixin_element;
      }
    }
  }
  return undefined;
}
/** Old implementation:
function getMixinAssocIfPublished(artifact, association){
  if(artifact.query && artifact.query.mixin){
    for(let elem of Object.keys(artifact.query.mixin)){
      const mixin_element= artifact.query.mixin[elem];
      if(mixin_element.name.id === association.name.id && mixin_element.name.absolute === association.name.absolute){
        return mixin_element;
      }
    }
  }
  return undefined;
}
*/

/**
 * Check wether the given artifact uses the given mixin association.
 *
 * @param {any} query Query of the artifact to check
 * @param {Element} association Mixin association to check for
 * @returns {Boolean} True if used
 */
function usesMixinAssociation(query, association, associationName) {
  if (query && query.SELECT && query.SELECT.columns) {
    for (let column of query.SELECT.columns) {
      if (column.ref && column.ref.length > 1 && (column.ref[0] == associationName || column.ref[0].id == associationName)) {
        // FIXME: This is not necessarily correct: the assoc name needs not be the first component, as e.g. $projection.assoc
        // would be also valid. Check other paths like $self.assoc ....
        return true;
      }
    }
  }
  return false;
}
/** Old implementation:
function usesMixinAssociation(artifact, association){
  if(artifact.elements){
    for(let elem of Object.keys(artifact.elements)){
      const element = artifact.elements[elem];
      if(element.value && element.value.path && element.value.path.length > 1 && element.value.path[0].id === association.name.id){
        return true;
      }
    }
  }
  return false;
}
*/



// Return a copy of the compact CSN model with a number of transformations made for rendering
// in HANA CDS style, used by 'toHana', toSql' and 'toRename'.
// The behavior is controlled by the following options:
// options = {
//    forHana.names                               // See the behavior of 'names' in toHana, toSql and toRename
//    forHana.associations                        // See the behavior of 'associations' in toHana and toSql
//                                                // (please note that toSql will always set at least 'mixin')
//    forHana.keepNamespaces                      // Do not transform namespaces to contexts (to be used for
//                                                // producing HANA-CDS compatible names with 'toHana', 'toSql' ...)
//    forHana.keepStructsAssocs                   // Do not flatten structs, do not convert managed assocs to
//                                                // unmanaged ones, do not convert assocs to joins (to be used
//                                                // for rendering strictly HANA-CDS compatible CDS source with
//                                                // 'toHana')
//    forHana.alwaysResolveDerivedTypes           // Always resolve derived type chains (by default, this is only
//                                                // done for 'quoted' names). FIXME: Should always be done in general.
// }
// The result model will always have 'options.forHana' set, to indicate that these transformations have happened.
// The following transformations are made:
// - (000) Some primitive type names are mapped to HANA type names (e.g. DateTime => UTCDateTime,
//         Date => LocalDate, ...).The primitive type 'UUID' is renamed to 'String' (see also 060 below).
// - (001) Add a temporal where condition to views where applicable before assoc2join
// - (010) (not for 'keepStructsAssocs'): Transform associations to joins if requested by option
//         'forHana.associations'
// - (015) Draft shadow entities are generated for entities/views annotated with '@odata.draft.enabled'.
// - (020) Check: in "plain" mode, quoted ids are not allowed.
//         (a) check in namespace declarations
//         (b) check in artifact/element definitions.
// - (030) ("plain" only) For all elements, derived types are replaced by their final base type.
// - (040) Abstract entities and entities 'implemented in' something are ignored, as well
//         as entities annotated with '@cds.persistence.skip' or '@cds.persistence.exists'.
// - (045) The query is stripped from entities that are annotated with '@cds.persistence.table',
//         essentially converting views to entities.
// - (050) Checks on the hierarchical model (pre-flattening)
//         array of, @cds.valid.from/to
// - (060) Users of primitive type 'UUID' (which is renamed to 'String' in 000) get length 36'.
// - (070) Default length 5000 is supplied for strings if not specified.
// - (080) Annotation definitions are ignored (note that annotation assignments are filtered out by toCdl).
// - (090) Compositions become associations.
// - (100) 'masked' is ignored (a), and attribute 'localized' is removed (b)
// - (110) Actions and functions (bound or unbound) are ignored.
// - (120) (a) Services become contexts.
//         (b) (not for 'keepNamespaces'): Namespaces become contexts.
// - (130) (not for 'keepStructsAssocs'): Elements having structured types are flattened into
//         multiple elements (using '_' or '.' as name separator, depending on 'forHana.names').
// - (140) (not for 'keepStructsAssocs'): Managed associations get explicit ON-conditions, with
//         generated foreign key elements (also using '_' or '.' as name separator, depending on 'forHana.names').
// - (150) (a) Elements from inherited (included) entities are copied into the receiving entity
//         (b) The 'include' property is removed from entities.
// - (160) Projections become views, with MIXINs for association elements (adding $projection where
//         appropriate for ON-conditions).
// - (170) ON-conditions referring to '$self' are transformed to compare explicit keys instead.
// - (180) In projections and views, ...
//         (a) association elements that are mixins must not be explicitly redirected
//         (b) MIXINs are created for association elements in the select list that are not mixins by themselves.
// - (190) For all enum types, ...
//         (a) enum constants in defaults are replaced by their values (assuming a matching enum as element type)
//         (b) the enum-ness is stripped off (i.e. the enum type is replaced by its final base type).
// - (200) The 'key' property is removed from all elements of types.
// - (210) (not for 'keepStructsAssocs'): Managed associations in GROUP BY and ORDER BY are
//         replaced by by their foreign key fields.
// - (220) Contexts that contain no artifacts or only ignored artifacts are ignored.
// - (230) (only for 'keepStructsAssocs'): The following are rejected in views
//         (a) Structured elements
//         (b) Managed association elements
//         (c) Managed association entries in GROUP BY
//         (d) Managed association entries in ORDER BY
// - (240) All artifacts (a), elements, foreign keys, parameters (b) that have a DB representation are annotated
//         with their database name (as '@cds.persistence.name') according to the naming convention chosen
//         in 'options.forHana.names'.
// - (250) Remove name space definitions again (only in forHanaNew). Maybe we can ommit inserting namespace definitions
//         completely (TODO)
function transformForHanaWithCsn(inputModel, options) {
  // copy the model as we don't want to change the input model
  let csn = cloneCsn(inputModel);

  const { error, warning, info, signal } = alerts(csn);

  options = mergeOptions(inputModel.options, options);
  setProp(csn, 'options', options);

  const pathDelimiter = (options.forHana.names == 'hdbcds') ? '.' : '_';

  const { addDefaultTypeFacets, flattenStructuredElement, flattenForeignKeys, checkForeignKeys,
    flattenStructStepsInRef, createForeignKeyElement, toFinalBaseType,
    isAssociationOperand, isDollarSelfOperand,
    createAndAddDraftAdminDataProjection, createScalarElement, createAssociationElement,
    addElement, copyAndAddElement, createAssociationPathComparison,
    extractValidFromToKeyElement, checkAssignment, checkMultipleAssignments,
    recurseElements
  } = transformUtils.getTransformers(csn, pathDelimiter);

  const {
    getArtifactDatabaseNameOf,
    isAssocOrComposition,
    isManagedAssociationElement,
    isStructured,
    isBuiltinType,
    getCsnDef,
    addStringAnnotationTo,
    getNamespaceOfArtifact,
    cloneWithTransformations,
    getFinalType
  } = getUtils(csn);

  const { artifactRef, inspectRef } = csnRefs(csn);

  // FIXME: This does something very similar to cloneWithTransformations -> refactor?
  const transformCsn = transformUtils.transformModel;

  // (000) Rename primitive types, make UUID a String
  transformCsn(csn, {
    type: (val, node, key) => {
      renamePrimitiveTypesAndUuid(val, node, key);
      addDefaultTypeFacets(node);
    },
    cast: (val) => {
      toFinalBaseType(val);
      renamePrimitiveTypesAndUuid(val.type, val, 'type');
      addDefaultTypeFacets(val);
    }
  });
  
  // (001) Add a temporal where condition to views where applicable before assoc2join
  //       assoc2join eventually rewrites the table aliases
  forEachDefinition(csn, (artifact, artifactName) => {
    addTemporalWhereConditionToView(artifact, artifactName);
    // Make sure that all source artifacts and association targets reach the database
    // (otherwise the view can't be activated), but only if the source artifact is NOT activated against the database
    if(!isNoDbArtifact(artifact) && !hasBoolAnnotation(artifact, '@cds.persistence.table') && artifact.query){
      forAllQueries(artifact.query, (query, path) => {
        checkQueryForNoDBArtifacts(query.SELECT || query.SET, path);
      }, ['definitions', artifactName, 'query'])
    }
  });

  // (010) If requested, translate associations to joins
  if (!options.forHana.keepStructsAssocs && options.forHana.associations != 'assocs') {
    csn = translateAssocsToJoins(csn);
  }

  // (030) - only for 'plain' names
  // For all elements, replace derived types by final base type
  // Needs to happen before setLengthForFormerUuid()
  // FIXME: Actually, we should simply do this always
  if (options.forHana.alwaysResolveDerivedTypes || options.forHana.names == 'plain') {
    forEachDefinition(csn, artifact => {
      forEachMemberRecursively(artifact, member => {
        toFinalBaseType(member);
      });
    });
  }


  // Process all artifacts (pass 1)
  forEachDefinition(csn, (artifact, artifactName) => {
    // (120 b) Namespaces become contexts (unless explicitly asked to keep them), except
    // the 'cds' namespace if not "extended" by cds.foundation
    handleContexts(artifactName);
    // (040) Ignore entities and views that are abstract or implemented
    // or carry the annotation cds.persistence.skip/exists
    // These entities are not removed from the csn, but flagged as "to be ignored"
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      if (artifact.abstract || hasBoolAnnotation(artifact, '@cds.persistence.skip') ||
        hasBoolAnnotation(artifact, '@cds.persistence.exists')) {
        artifact._ignore = true;
      }
    }

    const stripQueryish = artifact.query && hasBoolAnnotation(artifact, '@cds.persistence.table');
    // (045) Strip all query-ish properties from views and projections annotated with '@cds.persistence.table',
    // and make them entities
    if (stripQueryish) {
      artifact.kind = 'entity';
      delete artifact.query;
      delete artifact.$queries;
      delete artifact.$from;
      delete artifact.source;
    }

    // (050) Checks on the hierarchical csn (pre-flattening)
    if (artifact.kind === 'entity' && !artifact.query) {
      // only loop over the top-level members -> We do the recursive checking in the checkForArrayOf function.
      forEachMember(artifact, (member, memberName) => {
        checkForArrayOf(artifact, artifactName, member, memberName);
      })
    }

    let validFrom = [];
    let validTo   = [];
    let validKey  = [];

    recurseElements(artifact, [ 'definitions', artifactName ], (member, path) => {
      const [ f, t, k ] = extractValidFromToKeyElement(member, path);
      validFrom.push(...f);
      validTo.push(...t);
      validKey.push(...k);

    // All elements must have a type for this to work
      if (stripQueryish && !member.kind && !member.type)
        signal(error`All elements must have a type when entity is annotated with "@cds.persistence.table"`, path);
    });

    // (050) Check @cds.valid.from/to only on entity
    //       Views are checked in (001), unbalanced valid.from/to's or mismatching origins
    //       Temporal only in beta-mode
    if (artifact.kind == 'entity' && !artifact.query) {
      validFrom.forEach(obj => checkAssignment('@cds.valid.from', obj.element, obj.path, artifact));
      validTo.forEach(obj => checkAssignment('@cds.valid.to', obj.element, obj.path, artifact));
      validKey.forEach(obj => checkAssignment('@cds.valid.key', obj.element, obj.path, artifact));
      checkMultipleAssignments(validFrom, '@cds.valid.from', artifact, artifactName);
      checkMultipleAssignments(validTo, '@cds.valid.to', artifact, artifactName, true);
      checkMultipleAssignments(validKey, '@cds.valid.key', artifact, artifactName);
    }

    // if there is an cds.valid.key, make this the only primary key
    // otherwise add all cds.valid.from to primary key tuple
    if (validKey.length) {
      if (!validFrom.length || !validTo.length)
        signal(error`@cds.valid.key was used but @cds.valid.from and @cds.valid.to are missing`, [ 'definitions', artifactName ]);

      forEachMember(artifact, (member) => {
        if (member.key) {
          member.unique = true;
          delete member.key;
        }
      });
      validKey.forEach((member) => {
        member.element.key = true;
      });

      validFrom.forEach((member) => {
        member.element.unique = true;
      });
    }
    else {
      validFrom.forEach((member) => {
        member.element.key = true;
      });
    }
    // (120 a) Services become contexts
    if (artifact.kind == 'service') {
      artifact.kind = 'context';
    }

    // Do things specific for entities and views (pass 1)
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      transformEntityOrViewPass1(artifact, artifactName);
    }
    // (080) Ignore annotation declarations
    if (artifact.kind == 'annotation') {
      artifact._ignore = true;
    }

    // For generating DB stuff:
    // - table-entity with parameters: not allowed
    // - view with parameters: ok on HANA, not allowed otherwise
    // (don't complain about action/function with parameters)
    if (!artifact._ignore && artifact.params && (artifact.kind === 'entity' || artifact.kind === 'view')) {
      if (!artifact.query) { // table entity with params
        signal(error`"${artifactName}": Table-like entities with parameters are not supported for conversion to ${options.toSql ? 'SQL' : 'HANA CDS'}`, ["definitions", artifactName, "params"]);
      } else if (options.forHana.dialect !== 'hana') { // view with params
        signal(error`"${artifactName}": Entities with parameters are only supported on HANA`, artifact.location);
      } else {
        for (let pname in artifact.params) {
          if (pname.match(/\W/g) || pname.match(/^\d/) || pname.match(/^_/)) { // parameter name must be regular SQL identifier
            signal(warning`"${artifactName}", parameter "${pname}": is not a regular SQL identifier`, ["definitions", artifactName, "params", pname]);
          } else if (options.forHana.names !== 'plain' && pname.toUpperCase() !== pname) { // not plain mode: param name must be all upper
            signal(warning`"${artifactName}", parameter "${pname}": in naming mode "${options.forHana.names}" parameter names must be all uppercase`, artifact.params[pname].location);
          }
        }
      }
    }

    // Process the artifact's  members
    forEachMemberRecursively(artifact, (member, memberName, prop, path) => {
      // (100 a) Ignore the property 'masked' itself (but not its effect on projections)
      if (member.masked) {
        member._ignoreMasked = true;
      }
      // Report an error if a key is explicitly (!) nullable
      if (member.key && member.notNull === false) {
        signal(error`"${artifactName}.${memberName}": Key elements cannot be nullable in HANA CDS`, path);
      }

      // For HANA: Report an error on
      // - view with parameters that has an element of type association/composition
      // - association that points to entity with parameters
      if (options.forHana.dialect === 'hana' && isAssocOrComposition(member.type) && !options.betaMode) {
        if (artifact.params) {
          signal(error`"${artifactName}.${memberName}": Associations are not allowed in entities with parameters`, path);
        }
        if (csn.definitions[member.target].params) {
          signal(error`"${artifactName}.${memberName}": Associations cannot point to entities with parameters`, path);
        }
      }
    }, ["definitions", artifactName]);
  });

  // (170) Transform '$self' in backlink associations to appropriate key comparisons
  // Must happen before draft processing because the artificial ON-conditions in generated
  // draft shadow entities have crooked '_artifact' links, confusing the backlink processing.
  // But it must also happen after flattenForeignKeys has been called for all artifacts,
  // because otherwise we would produce wrong ON-conditions for the keys involved. Sigh ...
  forEachDefinition(csn, (artifact, artifactName, something, path) => {
    // Fixme: For toHana mixins must be transformed, for toSql -d hana
    // mixin elements must be transformed, why can't toSql also use mixins?
    doit(artifact.elements, path.concat(['elements']));
    if (artifact.query && artifact.query.SELECT && artifact.query.SELECT.mixin) {
      doit(artifact.query.SELECT.mixin, path.concat(['query','SELECT','mixin']));
    }
    function doit(dict, subPath) {
      for (let elemName in dict) {
        let elem = dict[elemName];
        if (isAssocOrComposition(elem.type) && elem.on) {
          processBacklinkAssoc(elem, elemName, artifact, artifactName, subPath.concat([elemName, 'on']));
        }
      }
    }
  });

  // (015) Generate artificial draft shadow entities if requested
  // Note that this needs to happen after implicit redirection has been performed, because it checks
  // for all draft nodes (additional artifacts reachable via compositions) to be part of a service.
  // This is typically achieved only by means of implicit redirection.
  forEachDefinition(csn, (artifact, artifactName) => {
    if ((artifact.kind == 'entity' || artifact.kind == 'view') && hasBoolAnnotation(artifact, '@odata.draft.enabled')) {
      // Ignore if not part of a service
      if (!artifact._service) {
        signal(warning`Ignoring annotation "@odata.draft.enabled" - artifact "${artifactName}" is not part of a service`, ["definitions", artifactName]);
        return;
      }
      // Determine the set of target draft nodes belonging to this draft root (the draft root
      // itself plus all its transitively composition-reachable targets)
      let draftNodes = Object.create(null);
      collectDraftNodesInto(artifact, artifact, draftNodes);
      // Draft-enable all of them
      for (let name in draftNodes) {
        generateDraftForHana(draftNodes[name]);
      }
      // Redirect associations/compositions between draft shadow nodes
      for (let name in draftNodes) {
        let shadowNode = csn.definitions[name + '_drafts'];
        // Might not exist because of previous errors
        if (shadowNode) {
          redirectDraftTargets(csn.definitions[name + '_drafts'], draftNodes);
        }
      }
    }
  });


  // Process all artifacts (pass 2)
  // Perform HANA-specific checks that require the whole csn to be processed
  // FIXME: Ideally, we could do this on-the-fly while processing artifacts, but because we do struct
  // flattening etc non-recursively, we need to wait till all artifacts are processed
  forEachDefinition(csn, (artifact, artifactName, property, path) => {
    if (!artifact._ignore) {
      // Some transformation for all kinds of artifacts
      transformCommon(artifact, artifactName, path);
      // (150 b) Strip inheritance
      // Note that this should happen after implicit redirection, because includes are required for that
      delete artifact.includes;
      // (240 a) Annotate artifacts with their DB names
      // Skip artifacts that have no DB equivalent anyway
      if (!['service', 'context', 'namespace', 'annotation', 'action', 'function'].includes(artifact.kind)) {
        addStringAnnotationTo('@cds.persistence.name', getArtifactDatabaseNameOf(artifactName, options.forHana.names, getNamespaceOfArtifact(artifactName)), artifact);
      }

      if(!isNoDbArtifact(artifact)) {
        // TODO: structure in CSN is artifact.query.[SELECT/SET].mixin
        if(artifact.query) {
          if(artifact.query.SELECT && artifact.query.SELECT.mixin){
            forEachGeneric(artifact.query.SELECT, 'mixin', ignoreAssociationToSkippedTarget, path.concat(['query','SELECT']));
          } else if(artifact.query.SET && artifact.query.SET.mixin){
            forEachGeneric(artifact.query.SET, 'mixin', ignoreAssociationToSkippedTarget, path.concat(['query','SET']));
          }
        }          
        forEachMemberRecursively(artifact, ignoreAssociationToSkippedTarget, ['definitions', artifactName]);
      }

      // Do things specific for entities and views (pass 2)
      if (artifact.kind == 'entity' || artifact.kind == 'view') {
        transformEntityOrViewPass2(artifact.query, artifact.elements, artifactName, artifact.$syntax, ['definitions', artifactName, 'query']);
        // (160) Projections now finally become views
        if (artifact.query)
          artifact.$syntax = 'view';
      }
      forEachMemberRecursively(artifact, (member, memberName, property, path) => {
        transformCommon(member, memberName, path);
        // (240 b) Annotate elements, foreign keys, parameters etc with their DB names
        // Virtual elements in entities and types are not annotated, as they have no DB representation.
        // In views they are, as we generate a null expression for them (null as <colname>)
        if ((!member.virtual || artifact.query)) {
          addStringAnnotationTo('@cds.persistence.name', getElementDatabaseNameOf(memberName, options.forHana.names), member);
        }
        // (20 a) If we keep associations as they are (hdbcds naming convention), we cannot have structured
        // view elements (we could enumerate the elements but we can't give them the names one would expect)
        if (options.forHana.keepStructsAssocs &&
          artifact.query &&
          isStructured(member)) {
          signal(error`With "hdbcds" naming, structured elements cannot be used in a view`, member.location);
          return;
        }
        // Check foreign keys of redirected associations
        if (!member._ignore && isAssocOrComposition(member.type)) {
          checkForeignKeys(member);
        }
        // (200) Strip 'key' property from type elements
        if (artifact.kind == 'type' && member.key) {
          delete member.key;
        }
      }, ["definitions", artifactName]);

      // (210) Fix GROUP BY, ORDER BY in views
      if (artifact.query) {
        replaceAssociationsInGroupByOrderBy(artifact, artifactName);
      }

      // (220) Weed out empty top-level contexts recursively (i.e. those that only have ignored content)
      if (artifact.kind == 'context' && getTopLevelArtifactNameOf(artifactName, csn) == artifactName) {
        ignoreContextsWithIgnoredContent(artifact, artifactName);
      }
    }
  });

  // (190 b) Replace enum types by their final base type and
  // (250) Remove all namespaces from definitions
  forEachDefinition(csn, (artifact, name) => {
    if (artifact.kind === 'namespace')
      delete csn.definitions[name];
    else {
      replaceEnumByBaseType(artifact);
      forEachMemberRecursively(artifact, (member) => {
        replaceEnumByBaseType(member);
        if (options.forHana.alwaysResolveDerivedTypes || options.forHana.names == 'plain') {
          toFinalBaseType(member);
          addDefaultTypeFacets(member);
        }
      });
    }
  });

  /*----------------------------------- Functions start here -----------------------------------------------*/

  function handleContexts(artifactName){
    const namespace = getNamespaceOfArtifact(artifactName);
    if (namespace && !csn.definitions[namespace]) {
      csn.definitions[namespace] = {
        kind: options.forHana.keepNamespaces ? 'namespace' : 'context'
      };

      handleContexts(namespace);
    }
  }
  
  /**
   * Add a where condition to views that
   * - are annotated with @cds.valid.from and @cds.valid.to,
   * - have only one @cds.valid.from and @cds.valid.to,
   * - and both annotations come from the same entity
   *
   * If the view has one of the annotations but the other conditions are not met, an error will be raised.
   *
   * @param {any} artifact
   */
  function addTemporalWhereConditionToView(artifact, artifactName) {
    if (artifact.query && artifact.query.SELECT) {
      // BLOCKER: We need information to handle $combined
      // What we are trying to achieve by this:
      // Forbid joining/selecting from two or more temporal entities
      // Idea: Follow the query-tree and check each from
      // Collect all source-entities and compute our own $combined
      const $combined = get$combined(artifact.query);
      let [from, to] = getFromToElements($combined);
      // exactly one validFrom & validTo
      if (from.length == 1 && to.length == 1) {
        // and both are from the same origin
        if (from[0].source === to[0].source && from[0].parent === to[0].parent) {
          let fromPath = {
            ref: [
              from[0].parent,
              from[0].name
            ]
          };

          let toPath = {
            ref: [
              to[0].parent,
              to[0].name
            ]
          };


          let atFrom = { ref : ['$at','from'] };
          let atTo = { ref: ['$at', 'to'] };

          let cond = ['(', fromPath, '<', atTo, 'and', toPath, '>', atFrom, ')'];

          if (artifact.query.SELECT.where) { // if there is an existing where-clause, extend it by adding 'and (temporal clause)'

            artifact.query.SELECT.where = ['(', ...artifact.query.SELECT.where, ')','and', ...cond];
          } else {
            artifact.query.SELECT.where = cond;
          }
        } else {
          signal(info`No temporal WHERE clause added as "${from[0].error_parent}"."${from[0].name}" and "${to[0].error_parent}"."${to[0].name}" are not of same origin`, ['definitions', artifactName]);
        }
      } else if (from.length > 0 || to.length > 0) {
        signal(info`No temporal WHERE clause added due to unbalanced @cds.valid.from/to`, ['definitions', artifactName]);
      }
    }
  }




  /**
   * Compute and return $combined for the given query.
   * 
   * @param {any} query Query
   * @returns {Map}
   */
  function get$combined(query){
    const sources = getSources(query);
    return sources;

    /**
     * Get the union of all elements from the from clause 
     * - descend into unions, following the lead query
     * - merge all queries in case of joins
     * - follow subqueries
     * 
     * @param {any} query Query to check
     * @returns {Map}
     */
    function getSources(query){
      if(query.SET){
        if(query.SET.args[0].elements){
          return mergeElementsIntoMap({}, query.SET.args[0].elements, query.SET.args[0].$location);
        } else {
          return getSources(query.SET.args[0]);
        }
      } else if(query.SELECT){
        if(query.SELECT.from.args){
          let elements = {};
          for(const subQuery of query.SELECT.from.args){
            if(subQuery.ref){
              const art = artifactRef(subQuery);
              elements = mergeElementsIntoMap(elements, art.elements, art.$location, subQuery.as || subQuery.ref[subQuery.ref.length-1], subQuery.ref[subQuery.ref.length-1] || subQuery.as);
            } else if(subQuery.SELECT || subQuery.SET){
              elements = mergeElementMaps(elements, getSources(subQuery));
            }
          }
  
          return elements;
        } else if(query.SELECT.from.ref){
          const art = artifactRef(query.SELECT.from);
          return mergeElementsIntoMap({}, art.elements, art.$location, query.SELECT.from.as || query.SELECT.from.ref[query.SELECT.from.ref.length-1], query.SELECT.from.ref[query.SELECT.from.ref.length-1] || query.SELECT.from.as );
        } else if(query.SELECT.from.SET || query.SELECT.from.SELECT){
          return getSources(query.SELECT.from);
        }
      }
  
      return {};
  
      /**
       * Merge two maps of elements together
       * 
       * @param {any} mapA Map a - will be returned
       * @param {any} mapB Map b - will not be returned
       * @returns {Map} mapA
       */
      function mergeElementMaps(mapA, mapB){
        for(const elementName in mapB){
          if(!mapA[elementName]){
            mapA[elementName] = [];
          }
          mapB[elementName].forEach(e => mapA[elementName].push(e));
        }
    
        return mapA;
      }
    
      /**
       * Merge elements into an existing map
       * 
       * @param {any} existingMap map to merge into - will be returned
       * @param {any} elements elements to merge into the map
       * @param {any} $location $location of the elements - where they come from
       * @param {any} parent Name of the parent of the elements, alias before ref
       * @param {any} error_parent Parent name to use for error messages, ref before alias
       * @returns {Map} existingMap
       */
      function mergeElementsIntoMap(existingMap, elements, $location, parent, error_parent){
        for(const elementName in elements){
          const element = elements[elementName];
          if(!existingMap[elementName]){
            existingMap[elementName] = [];
          }
          existingMap[elementName].push({ element: element, name: elementName, source: $location, parent: parent, error_parent: error_parent });
        }
    
        return existingMap;
      }
    }
  }

  /**
   * Get all elements tagged with @cds.valid.from/to from the union of all entities of the from-clause.
   * 
   * @param {any} combined union of all entities of the from-clause
   * @returns {Array[]} Array where first field is array of elements with @cds.valid.from, second field is array of elements with @cds.valid.to.
   */
  function getFromToElements(combined) {
    let from = [], to = [];
    for(let name in combined) {
      let elt = combined[name];
      if(!Array.isArray(elt))
        elt = [elt];
      elt.forEach(e => {
        if(hasBoolAnnotation(e.element, '@cds.valid.from')){
          from.push(e);
        } 
        if(hasBoolAnnotation(e.element, '@cds.valid.to')){
          to.push(e);
        }
      });
    }

    return [from,to];
  }

  /**
   * Check if any warnings were raised in earlier steps that need to be reclassified - i.e. as errors
   *
   * @param {any} csn The csn
   * @returns {Array} Reclassified messages-Array
   */
  function reclassifyWarnings(csn) {
    return csn.messages.map(message => {
      switch (message.messageId) {
        case 'to-many-no-on':
          if (!message.context.EntityhasPersistenceSkipOrTrueOrAbstract) message.severity = 'Error';
          break;
      }
      return message;
    })

  }
  if (csn.messages)
    csn.messages = reclassifyWarnings(csn);
  // Throw up if we have errors
  if (hasErrors(csn.messages)) {
    throw new CompilationError(sortMessages(csn.messages), csn)
  }

  return csn;

  // Associations that target a @cds.persistence.skip artifact must be removed from the persistence model
  function ignoreAssociationToSkippedTarget(member, memberName, prop, path) {
    if(!member._ignore && isAssocOrComposition(member.type) && isNoDbArtifact(csn.definitions[member.target])){
      signal(info`"${path[1]}": Removing ${getFinalType(member.type).replace('cds.', '')} "${memberName}", Target "${member.target}" is either 'abstract' or annotated with '@cds.persistence.skip'`, path);
      member._ignore = true;
    }
  }

  /*
    If the artifact is either abstract or assigned '@cds.persistence.skip' it never reaches the Database layer
  */
  function isNoDbArtifact(art) {
    return ['entity', 'view'].includes(art.kind) && (art.abstract || hasBoolAnnotation(art, '@cds.persistence.skip'));
  }

  // Traverse artifact 'art', set '_ignore' for all contexts that only contain ignored artifacts
  function ignoreContextsWithIgnoredContent(art, artName) {
    // We only care for non-ignored contexts
    if (art._ignore || art.kind != 'context') {
      return;
    }
    // Descend into children, note if any is non-ignored
    let hasNonIgnoredChildren = false;
    const contextChildren = getArtifactsInsideContext(artName);
    for (let childName in  contextChildren) {
      let child = contextChildren[childName];
      ignoreContextsWithIgnoredContent(child, childName);
      if (!child._ignore) {
        hasNonIgnoredChildren = true;
      }
    }
    if (!hasNonIgnoredChildren) {
      // If we get here, the context was either empty or everything in it was ignored.
      // We currently preserve empty contexts - might also ignore them if we later decide so
      if (Object.keys(contextChildren).length > 0) {
        art._ignore = true;
      }
    }
  }

  /**
   * Returns the artifacts inside of a context (also transitively!) 
   * 
   * @param {any} contextName Name of the context
   * @returns {Dictionary} 
   */
  function getArtifactsInsideContext(contextName){
    const artifacts = {};
    forEachDefinition(csn, (artifact, artifactName) => {
      if(artifactName.startsWith(contextName + '.') && artifactName !== contextName){
        artifacts[artifactName] = artifact;
      }
    });

    return artifacts;
  }

  // Perform transformations common to artifacts and members (in place)
  // Note that this should happen after implicit redirection and draft enabling, because
  // it would take away information required by those.
  function transformCommon(obj, objName, path) {
    // (060) Set length 36 for former type UUID (now String after 000)
    //setLengthForFormerUuid(obj);    // already done in step 000, so probably no longer needed here
    //setLengthForFormerUuid(obj.items); // already done in step 000, so probably no longer needed here
    // (070) Supply default length 5000 for strings if not specified
    // FIXME: Do we really want this?
    //addDefaultTypeFacets(obj);  // already done in step 000, so probably no longer needed here
    //addDefaultTypeFacets(obj.items);   // already done in step 000, so probably no longer needed here
    // (090) Compositions become associations
    /* Old if:
    if (obj.type && obj.type._artifact.name.absolute && obj.type._artifact.name.absolute == 'cds.Composition') {
        obj.type.path = [{id: obj.type.absolute}];
        setProp(obj.type, '_artifact', csn.definitions['cds.Association']);
        setProp(obj.type.path[0], '_artifact', csn.definitions['cds.Association']);
    }
    */
    if (obj.type === 'cds.Composition') {
      obj.type = 'cds.Association';
    }
    // (100 b) Remove attribute 'localized'
    delete obj.localized;
    // (080) and (110) Ignore annotation declarations, actions and functions
    if (obj.kind == 'annotation' || obj.kind == 'action' || obj.kind == 'function') {
      obj._ignore = true;
    }
    // Check type parameters (length, precision, scale ...)
    if (!obj._ignore && obj.type) {
      checkTypeParameters(obj, csn);
    }
    if (!obj._ignore && obj.items && obj.items.type) {
      checkTypeParameters(obj.items, csn);
    }
    // (190 a) Replace enum symbols by their value (if found)
    replaceEnumSymbolsByValues(obj, path);
  }

  // Change the names of those builtin types that have different names in HANA.
  // (do that directly in the csn where the builtin types are defined, so that
  // all users of the types benefit from it). Also add the type parameter 'length'
  // to 'UUID' (which becomes a string).
  // TODO: there is no benefit at all - it is fundamentally wrong
  function renamePrimitiveTypesAndUuid(val, node, key) {
    // assert key === 'type'
    const hanaNamesMap = {
      'cds.DateTime' : 'cds.UTCDateTime',
      'cds.Timestamp' : 'cds.UTCTimestamp',
      'cds.Date' : 'cds.LocalDate',
      'cds.Time' : 'cds.LocalTime',
      'cds.UUID' : 'cds.String',
    }
    node[key] = hanaNamesMap[val] || val;
    if (val === 'cds.UUID' && !node.length)
      node.length = 36;
    // Length/Precision/Scale is done in addDefaultTypeFacets
  }

  // If 'obj' has final type 'cds.UUID' (renamed to String in 000), set its length to 36.
  // function setLengthForFormerUuid(obj) {
  //   if (!obj || !obj.type)
  //     return;
  //   if (obj.type === 'cds.UUID' && !obj.length) {
  //     obj.length = 36;
  //   }
  // }


  // Perform first pass of all transformations required for an entity or a projection entity or a view (in place)
  function transformEntityOrViewPass1(art, artName) {
    // (130) First walk through the entity elements: Flatten structs (might result in new elements)
    // (unless explicitly asked to keep structs)
    if (!options.forHana.keepStructsAssocs) {
      for (let elemName in art.elements) {
        let elem = art.elements[elemName];
        if (isStructured(elem)) {
          // Ignore the structured element, replace it by its flattened form
          // TODO: use $ignore - _ is for links
          elem._ignore = true;
          let flatElems = flattenStructuredElement(elem, elemName);
          for (let flatElemName in flatElems) {
            if (art.elements[flatElemName]) {
              signal(error`"${artName}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, elem.location);
            }
            art.elements[flatElemName] = flatElems[flatElemName];
            // FIXME: Should also adapt indexNo of the newly added elements and all subsequent ones
          }
          // Don't delete the property, make it non-enumerable
          setProp(art.elements, elemName, art.elements[elemName]);
        }
      }
    }

    // Flatten structs in indexes and partitions (unless explicitly asked to keep structs)
    let tc = art.technicalConfig;
    if (!options.forHana.keepStructsAssocs) {
      if (tc) {
        // Secondary and fulltext indexes
        for (let name in tc.indexes) {
          let index = tc.indexes[name];
          // Array of indexes is an error: multiple index definitions with same name.
          // However, if it has survived until here, behave correctly
          if (Array.isArray(index)) {
            index.forEach(idx => {
              checkFTIColumns(idx);
              flattenStructuredColumnPaths(idx.columns);
            });
          } else {
            checkFTIColumns(index);
            flattenStructuredColumnPaths(index.columns);
          }
        }
        if (tc.fzindexes) {
          tc.fzindexes.forEach(idx => {
            flattenStructuredColumnPaths(idx.columns);
          });
        }
        // Partition columns
        if (tc.partition) {
          tc.partition.specs.forEach(spec => flattenStructuredColumnPaths(spec.columns));
        }
      }
    }
    // TODO: XSN
    function checkFTIColumns(index) {
      if (index.kind === 'fulltextindex') {
        index.columns.filter(col => isStructured(col._artifact)).forEach(col => {
          signal(error`"${artName}": A fulltext index cannot be defined on a structured element "${col._artifact.name.absolute}`,
            col.location);
        });
      }
    }

    // Flatten structs used in refs (unless explicitly asked to keep structs)
    if (!options.forHana.keepStructsAssocs) {
      forEachRef(art, (ref, refOwner, path) => {
        refOwner.ref = flattenStructStepsInRef(ref, path);
        if (refOwner.ref[refOwner.ref.length-1] != ref[ref.length-1] && insideColumns(path) && !refOwner.as)
          refOwner.as = ref[ref.length-1];
      },["definitions", artName]);
    }

    // after all paths have been flattened "a_b_c", assign fuzzy index definitions
    // to the flattened element
    // FIXME: This will no longer be necessary once we have moved to toSqlNew (not preserved in compact CSN anyway)
    // TODO: XSN - comment makes it seem like this is no longer needed?
    if (tc && tc.fzindexes) {
      tc.fzindexes.forEach(idx => {
        idx.columns.forEach(col => {
          if (!col._ignore) {
            setProp(art.elements[col.path[0].id], '_fzindex', idx); // last one wins on multiple occurences
          }
        });
      });
    }

    // Second walk through the entity elements: Deal with associations (might also result in new elements)
    for (let elemName in art.elements) {
      let elem = art.elements[elemName];
      // (140) Generate foreign key elements and ON-condition for managed associations
      // (unless explicitly asked to keep assocs unchanged)
      if (!options.forHana.keepStructsAssocs) {
        if (isManagedAssociationElement(elem)) {
          // Aliased foreign keys in managed associations not yet allowed (only check for non-projections, to avoid duplicate errors)
          if (!elem.query) {
            for (let name in elem.keys) {
              let foreignKey = elem.keys[name];
              // FIXME: what do .calculated and .$inferred mean? CSN/XSN?
              if (!foreignKey.calculated && !foreignKey.$inferred && foreignKey.as) {
                signal(error`Aliases for foreign keys are not supported yet with --to-hana`,
                  ["definitions", artName, "elements", elemName]);
              }
            }
          }
          // Flatten foreign keys (replacing foreign keys that are managed associations by their respective foreign keys)
          flattenForeignKeys(elem);
          // Generate foreign key elements for managed associations, and assemble an ON-condition with them
          let onCondParts = [];
          let join_with_and = false;
          for (let name in elem.keys) {
            let foreignKey = elem.keys[name]
            // Assemble left hand side of 'assoc.key = fkey'
            let assocKeyArg = {
              ref: [
                elemName
              ].concat(foreignKey.ref),
            }
            // Assemble right hand side of 'assoc.key = fkey'
            createForeignKeyElement(elem, elemName, foreignKey, art);
            let fKeyArg = {
              ref: [
                foreignKey.$generatedFieldName
              ],
            }

            if(join_with_and){ // more than one FK
              onCondParts.push('and')
            }

            onCondParts.push(
              assocKeyArg
            );
            onCondParts.push('=');
            onCondParts.push(fKeyArg);
            
            if(!join_with_and){
              join_with_and = true;
            }
          }

          elem.on = onCondParts;

          // If the managed association has a 'key' property => remove it as unmanaged assocs cannot be keys
          // TODO: Are there other modifiers (like 'key') that are valid for managed, but not valid for unmanaged assocs?
          if (elem.key) {
            delete elem.key;
          }

          // If the managed association has a 'not null' property => remove it
          if (elem.notNull) {
            delete elem.notNull;
          }

          // The association is now unmanaged, i.e. actually it should no longer have foreign keys
          // at all. But the processing of backlink associations below expects to have them, so
          // we don't delete them (but mark them as implicit so that toCdl does not render them)
          /* Skip for now - forHana adds this to elements, but it is not part of the resulting CSN
             forHanaNew -> Somehow ends up in the CSN?!
             elem.implicitForeignKeys = true;
          */
        }
      }
    }

    /*
      For each path node of the columns array do:
        1) Store current path node in newColumns
        2) If the column path terminates in a structured type:
           (but not a managed association, this requires much more effort!)
          2a) Generate all leaf paths originating from this structured type.
              Every path step of the new leaf paths has an _artifact reference to
              it's corresponding definition element.
              Prepend the column path as prefix to all leaf paths and create a new path object
              with attributes { path, absolute, element, _artifact, calculated: true }
          2b) Propagate all properties from original path node to the resulting flattened path
              node, except for [ path, absolute, element, location, calculated ].
          2c) Set leaf _artifact as _artifact to flattened path node.
          2d) Add the new path node to newColumns.
          2e) Mark the original path node with _ignore=true.
        3) Replace the content of original columns with the content of newColumns if required
    */
    function flattenStructuredColumnPaths(columns) {
      if (columns === undefined) {
        return;
      }
      let newColumns = [];
      columns.forEach(col => {
        newColumns.push(col);
        if (col._artifact.elements) {
          let flattenedPaths = getLeafPathsForStructuredElement(col._artifact, col.path);
          flattenedPaths.forEach(fp => {
            let flatCol = {
              path: fp,
              absolute: col.absolute,
              element: fp.map(f => f.id).join('.'),
              calculated: true
            };
            Object.keys(col).forEach(k => {
              if (!['path', 'absolute', 'element', 'location', 'calculated'].includes(k))
                flatCol[k] = col[k];
            });
            setProp(flatCol, '_artifact', fp[fp.length - 1]._artifact);
            newColumns.push(flatCol);
          });
          col._ignore = true;
        }
      });
      if (columns.length < newColumns.length) {
        columns.splice(0, columns.length, ...newColumns);
      }

      function getLeafPathsForStructuredElement(elt, prefixPath = []) {
        let paths = [];
        if (elt.elements) {
          for (let name in elt.elements) {
            let sub = elt.elements[name];
            paths = paths.concat(getLeafPathsForStructuredElement(sub, [newPathStep(sub)]));
          }
          return paths.map(p => prefixPath.concat(p));
        } else {
          return prefixPath;
        }

        function newPathStep(elt) {
          let node = {
            id: elt.name.id
          };
          setProp(node, '_artifact', elt);
          return node;
        }
      }
    }
  }

  function transformEntityOrViewPass2(query, elements, artName, type, path, insideUnion = false) {
    if (query && query.SET) {
      for(let i = 0; i < query.SET.args.length; i++){
        const q = query.SET.args[i];
        transformEntityOrViewPass2(q, q === query.SET.args[0] ? elements : q.elements, artName, type, path.concat(['SET', 'args', i]), query.SET.op === 'union');
      }
      return;
    }
    elements = elements || query.elements;
    let hasNonAssocElements = false;
    const isSelect = query && query.SELECT;
    let isProjection = type === 'projection';
    const columnMap = {};
    let isSelectStar = false;
    if(isSelect){
      if (query.SELECT.from && query.SELECT.from.SELECT)
        transformEntityOrViewPass2(query.SELECT.from, query.SELECT.from.elements, artName, type, path.concat(['SELECT','from']));
      if(!query.SELECT.columns){
        isProjection = true;
      } else {
        query.SELECT.columns.forEach(col => {
          if (col == '*') {
            isSelectStar = true;
          }
          else if (col.as) {
            if(!columnMap[col.as])
              columnMap[col.as] = col;
          }
          else if(col.ref) {
            if(!columnMap[col.ref[col.ref.length - 1]])
              columnMap[col.ref[col.ref.length - 1]] = col;
          }
          else {
            if(!columnMap[col])
              columnMap[col] = col;
          }
        })
      }
    }
    if(query && ( options.forHana || (options.toSql && options.toSql.dialect === 'hana'))){
      // check all querys/subqueries for mixin publishing inside of unions -> forbidden in hdbcds
      if(query.SELECT && query.SELECT.mixin && insideUnion){
        for(let elementName in elements){
          const element = elements[elementName];
          if(element.target){
            let colLocation;
            for(let i = 0; i < query.SELECT.columns.length; i++){
              const col = query.SELECT.columns[i];
              if(col.ref && col.ref.length === 1){
                if(!colLocation && col.ref[0] === elementName){
                  colLocation = i;
                }

                if(col.as === elementName){
                  colLocation = i;
                }
              }
            }
            const matchingCol = query.SELECT.columns[colLocation];
            const possibleMixinName = matchingCol.ref[0];
            const isMixin = query.SELECT.mixin[possibleMixinName] !== undefined;
            if(element.target && isMixin){
              signal(error`Element "${elementName}" is a mixin association${possibleMixinName !== elementName ? ` ("${possibleMixinName}")` : ''} and cannot be published in a UNION.`, path.concat(['SELECT', 'columns', colLocation]));
            }
          }

        }
      }
    }
    
    // Second walk through the entity elements: Deal with associations (might also result in new elements)

    // Will be initialized JIT inside the elements-loop
    let $combined;

    for (let elemName in elements) {
      let elem = elements[elemName];
      if (isSelect) {
        if (!columnMap[elemName]) {
          // Prepend an alias if present
          let alias = (isProjection || isSelectStar) 
              && (query.SELECT.from.as || getAliasName(query.SELECT.from.ref, path.concat(['SELECT', 'from'])))
          // In case of * and no explicit alias
          // find the source of the col by looking at $combined and prepend it
          if(isSelectStar && !alias && !isProjection){
            if(!$combined){
              $combined = get$combined(query);
            }
            
            const matchingCombined = $combined[elemName];
            // Internal errors - this should never happen!
            if(matchingCombined.length > 1){ // should already be caught by compiler
              throw new Error(`Ambigous name - cannot be resolved: ${elemName}. Found in: ${matchingCombined.map(o => o.parent)}`);
            } else if(matchingCombined.length === 0){ // no clue how this could happen? Invalid CSN?
              throw new Error(`No matching entry found in UNION of all elements for: ${elemName}`);
            }
            alias = matchingCombined[0].parent;
          }
          if (alias) {
            columnMap[elemName] = { ref: [alias, elemName] };
          } else {
            columnMap[elemName] = { ref: [elemName] };
          }
        }

        // For associations - make sure that the foreign keys have the same "style"
        // If A.assoc => A.assoc_id, else if assoc => assoc_id or assoc as Assoc => Assoc_id
        if (elem.keys) {
          const assoc_col = columnMap[elemName];
          if (assoc_col && assoc_col.ref) {
            elem.keys.forEach(key => {
              const ref = cloneCsn(assoc_col.ref);
              ref[ref.length-1] = [ref[ref.length-1]].concat(key.ref).join('_');
              const result = {
                ref: ref
              };
              if(assoc_col.as){
                result.as = key.$generatedFieldName;
              }

              const colName = result.as || ref[ref.length-1];
              columnMap[colName] = result;
            });
          }
        }
      }
      // Views must have at least one element that is not an unmanaged assoc
      if (!elem.on && !elem._ignore) {
        hasNonAssocElements = true;
      }

      // (230 b) If we keep associations as they are (hdbcds naming convention), we cannot have managed associations
      // as view elements (their foreign keys cannot be addressed in the view)
      if (options.forHana.keepStructsAssocs &&
        query &&
        isAssocOrComposition(elem.type) &&
        !elem.onCond) {
        signal(error`With "hdbcds" naming, managed association elements cannot be used in a view`, ['definitions', artName, 'elements', elemName]);
        continue;
      }

      // (180 b) Create MIXINs for association elements in projections or views (those that are not mixins by themselves)
      // CDXCORE-585: Allow mixin associations to be used and published in parallel
      if (query !== undefined && isAssocOrComposition(elem.type)) {
        /* Old implementation:
        const isNotMixinByItself = !(elem.value && elem.value.path && elem.value.path.length == 1 && art.query && art.query.mixin && art.query.mixin[elem.value.path[0].id]);
        */
        const isNotMixinByItself = checkIsNotMixinByItself(query, elem, elemName);
        const correspondingMixin = getMixinAssocOfQueryIfPublished(query, elem, elemName);
        if (isNotMixinByItself || correspondingMixin !== undefined) {
          // If the mixin is only published and not used, only display the __ clone. Ignore the "original".
          if (correspondingMixin !== undefined && !usesMixinAssociation(query, elem, elemName)) {
            correspondingMixin._ignore = true;
          }
          delete elem._typeIsExplicit;
          // Create an unused alias name for the MIXIN
          let mixinElemName = '__' + elemName;
          while (elements[mixinElemName]) {
            mixinElemName = '_' + mixinElemName;
          }
          // Copy the association element to the MIXIN clause under its alias name
          // (shallow copy is sufficient, just fix name and value)
          let mixinElem = Object.assign({}, elem);
          // Perform common transformations on the newly generated MIXIN element (won't be reached otherwise)
          transformCommon(mixinElem, mixinElemName);
          // TODO: Can we rely on query.SELECT.mixin to check for mixins?
          // Yes, we can - only SELECT can have mixin. But:
          // - UNION
          // - JOINS
          // - Subqueries
          // Are currently (and in the old transformer) not handled!
          if (query.SELECT && !query.SELECT.mixin) {
            query.SELECT.mixin = Object.create(null);
          }
          // Let the original association element use the newly generated MIXIN name as value and alias
          delete elem.viaAll;

          // Clone 'onCond', prepending '$projection' to paths where appropriate,
          // and fixing the association alias just created

          if (mixinElem.on) {
            mixinElem.on = cloneWithTransformations(mixinElem.on, {
              ref: (ref) => {
                // Clone the path, without any transformations
                let clonedPath = cloneWithTransformations(ref, {}, true);
                // Prepend '$projection' to the path, unless the first path step is the (mixin) element itself or starts with '$')
                if (clonedPath[0] == elemName) {
                  clonedPath[0] = mixinElemName;
                } else if (!clonedPath[0].startsWith('$')) {
                  let projectionId = '$projection';
                  clonedPath.unshift(projectionId);
                } else if (clonedPath[0] == '$self') {
                  clonedPath[0] = '$projection';
                }
                return clonedPath;
              },
              func: (func) => {
                // Unfortunately, function names are disguised as paths, so we would prepend a '$projection'
                // above (no way to distinguish that in the callback for 'path' above). We can only pluck it
                // off again here ... sigh
                if (func.ref && func.ref[0] && func.ref[0] == '$projection') {
                  func.ref = func.ref.slice(1);
                }
                return func;
              }
            }, true);
          }

          if(!mixinElem._ignore){
            columnMap[elemName] = {ref: [mixinElemName], as: elemName };
          }

          if(query.SELECT){
            query.SELECT.mixin[mixinElemName] = mixinElem;
          }
        }
      }
    }

    if (query && !hasNonAssocElements) {
      // Complain if there are no elements other than unmanaged associations
      signal(error`"${artName}": For HANA CDS or SQL, a view or projection must have at least one element that is not an unmanaged association`, ['definitions', artName]);
    }

    if(isSelect){
      // Workaround for bugzilla 176495 FIXME FIXME FIXME: is this really still needed?
      // If a select item of a cdx view contains an expression, the result type cannot be computed
      // but must be explicitly specified. This is important for the OData channel, which doesn't
      // work if the type is missing (for HANA channel an explicit type is not required, as HANA CDS
      // can compute the result type).
      // Due to bug in HANA CDS, providing explicit type 'LargeString' or 'LargeBinary' causes a
      // diserver crash. Until a fix in HANA CDS is available, we allow to suppress the explicit
      // type in the HANA channel via an annotation.
      Object.keys(columnMap).forEach((value) => {
        let elem = elements[value];
        if (elem && elem["@cds.workaround.noExplicitTypeForHANA"])
          delete columnMap[value].cast;
      })

      query.SELECT.columns = Object.keys(elements).filter(elem => !elements[elem]._ignore).map(key => columnMap[key]);
      delete query.SELECT.excluding;  // just to make the output of the new transformer the same as the old
    }
  }
  

  // If 'elem' has a default that is an enum constant, replace that by its value. Complain
  // if not found or not an enum type,
  function replaceEnumSymbolsByValues(elem, path) {
    // (190 a) Replace enum symbols by their value (if found)
    if (elem.default && elem.default['#']) {
      let Enum = elem.enum;
      if (!Enum && !isBuiltinType(elem.type)) {
        let typeDef = getCsnDef(elem.type);
        Enum = typeDef && typeDef.enum;
      }
      if (!Enum) {
        // Not an enum at all
        signal(error`Enum literal "#${elem.default['#']}" can only be used with an enum type in HANA CDS`, path);
      }
      else {
        // Try to get the corresponding enum symbol from the element's type
        let enumSymbol = Enum[elem.default['#']];
        if (!enumSymbol) {
          signal(error`Enum literal "#${elem.default['#']}" not found in enumeration type`, path);
        }
        else if (enumSymbol.val) {
          // Replace default with enum value
          elem.default.val = enumSymbol.val;
          delete elem.default['#'];
        }
        else {
          // Enum symbol without explicit value - replace default by the symbol in string form
          elem.default.val = elem.default['#'];
          delete elem.default['#'];
        }
      }
    }
  }

  // If 'node' has an enum type, change node's type to be the enum's base type
  // and strip off the 'enum' property.
  function replaceEnumByBaseType(node) {
    if (node.items) {
      replaceEnumByBaseType(node.items);
    }
    // (190 b) Replace enum types by their final base type (must happen after 190 a)
    /* Old implementation:
    if (node && node._finalType && (node.enum || node._finalType.enum)) {
      node.type = node._finalType.type
      // node.type = node._finalType.type._artifact._finalType.type;
      if (node._finalType.length) {
        node.length = node._finalType.length;
      }
      setProp(node, '_finalType', node.type._artifact);
      delete node.enum;
    }
    */
    if (node && node.enum) {
      //toFinalBaseType(node);
      //addDefaultTypeFacets(node);
      delete node.enum;
    }
  }

  // If the association element 'elem' of 'art' is a backlink association, massage its ON-condition
  // (in place) so that it
  // - compares the generated foreign key fields of the corresponding forward
  //   association with their respective keys in 'art' (for managed forward associations)
  // - contains the corresponding forward association's ON-condition in "reversed" form,
  //   i.e. as seen from 'elem' (for unmanaged associations)
  // Otherwise, do nothing.
  function processBacklinkAssoc(elem, elemName, art, artName, pathToOn) {
    // This is an ON-condition in token-stream form
    let xprArgs = elem.on;
    // Don't add braces if it is a single expression (ignoring superfluos braces)
    const multipleExprs = xprArgs.filter(x => x !== '(' && x !== ')' ).length > 3;
    let result = [];
    let i = 0;
    while (i < xprArgs.length) {
        // Only token tripel `<path>, '=', <path>` are of interest here
      if (i < xprArgs.length - 2 && xprArgs[i + 1] == '=') {
          // Check if one side is $self and the other an association
          // (if so, replace all three tokens with the condition generated from the other side, in parentheses)
        if (isDollarSelfOperand(xprArgs[i]) && isAssociationOperand(xprArgs[i + 2], pathToOn.concat([i+2]))) {
          const assoc = inspectRef(pathToOn.concat([i+2])).art;
          if(multipleExprs)
            result.push('(');
          result.push(...transformDollarSelfComparison(xprArgs[i + 2], assoc, xprArgs[i + 2].ref[xprArgs[i + 2].ref.length -1], elem, elemName, art, artName, pathToOn.concat([i])));
          if(multipleExprs)
            result.push(')');
          i += 3;
        } else if (isDollarSelfOperand(xprArgs[i + 2]) && isAssociationOperand(xprArgs[i], pathToOn.concat([i]))) {
          const assoc = inspectRef(pathToOn.concat([i])).art;
          if(multipleExprs)
            result.push('(');
          result.push(...transformDollarSelfComparison(xprArgs[i], assoc, xprArgs[i].ref[xprArgs[i].ref.length -1],  elem, elemName, art, artName, pathToOn.concat([i + 2])));
          if(multipleExprs)
            result.push(')');
          i += 3;
        }
          // Otherwise take one (!) token unchanged
        else {
          result.push(xprArgs[i]);
          i++;
        }
      }
        // Take all other tokens unchanged
      else {
        result.push(xprArgs[i]);
        i++;
      }
    }
    elem.on = result;

    // Return the condition to replace the comparison `<assocOp> = $self` in the ON-condition
    // of element <elem> of artifact 'art'. If there is anything to complain, use location <loc>
    function transformDollarSelfComparison(assocOp, assoc, assocName, elem, elemName, art, artifactName, path) {
      // Check: The forward link <assocOp> must point back to this artifact
      // FIXME: Unfortunately, we can currently only check this for non-views (because when a view selects
      // a backlink association element from an entity, the forward link will point to the entity,
      // not to the view).
      // FIXME: This also means that corresponding key fields should be in the select list etc ...
      if (!art.query && assoc.target && assoc.target != artifactName) {
        signal(error`Only an association that points back to this artifact can be compared to "$self"`, path);
      }

      // Check: The forward link <assocOp> must not contain '$self' in its own ON-condition
      if (assoc.on) {
        const containsDollarSelf = assoc.on.some(isDollarSelfOperand);

        if (containsDollarSelf) {
          signal(error`An association that uses "$self" in its ON-condition cannot be compared to "$self"`, path);
        }
      }

      // Transform comparison of $self to managed association into AND-combined foreign key comparisons
      if (assoc.keys) {
        return transformDollarSelfComparisonWithManagedAssoc(assocOp, assoc, assocName, elemName, path);
      }
      // Transform comparison of $self to unmanaged association into "reversed" ON-condition
      else if (assoc.on) {
        return transformDollarSelfComparisonWithUnmanagedAssoc(assocOp, assoc, assocName, elemName, path);
      } else {
        throw new Error(`Expected either managed or unmanaged association in $self-comparison: ${JSON.stringify(elem.on)}`);
      }
    }

    // For a condition `<elemName>.<assoc> = $self` in the ON-condition of element <elemName>,
    // where <assoc> is a managed association, return a condition comparing the generated
    // foreign key elements <elemName>.<assoc>_<fkey1..n> of <assoc> to the corresponding
    // keys in this artifact.
    // For example, `ON elem.ass = $self` becomes `ON elem.ass_key1 = key1 AND elem.ass_key2 = key2`
    // (assuming that `ass` has the foreign keys `key1` and `key2`)
    function transformDollarSelfComparisonWithManagedAssoc(assocOp, assoc, originalAssocName, elemName) {
      const conditions = [];
      // if the element was structured then it was flattened => change of the delimiter from '.' to '_'
      // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
      let assocName = originalAssocName.replace(/\./g, pathDelimiter);
      elemName = elemName.replace(/\./g, pathDelimiter);

      assoc.keys.forEach(k => {
        // Depending on naming conventions, the foreign key may two path steps (hdbcds) or be a single path step with a flattened name (plain, quoted)
        let fKeyPath = options.forHana.keepStructsAssocs ? [assocName, ...k.ref]: [`${assocName}${pathDelimiter}${k.ref[0]}`];
        // FIXME: _artifact to the args ???
        let a = [
          {
            ref: [elemName, ...fKeyPath]
          },
          { ref: k.ref }
        ];

        conditions.push([a[0], '=', a[1]]);
      });

      const result = conditions.reduce((prev,current) => {
        if(prev.length === 0){
          return [...current];
        }
        return [...prev, 'and', ...current];
      }, [])

      return result;
    }

    // For a condition `<elemName>.<assoc> = $self` in the ON-condition of element <elemName>,
    // where <assoc> is an unmanaged association, return the ON-condition of <assoc> as it would
    // be written from the perspective of the artifact containing association <elemName>.
    // For example, `ON elem.ass = $self` becomes `ON a = elem.x AND b = elem.y`
    // (assuming that `ass` has the ON-condition `ON ass.a = x AND ass.b = y`)
    function transformDollarSelfComparisonWithUnmanagedAssoc(assocOp, assoc, originalAssocName, elemName) {
      // if the element was structured then it may have been flattened => change of the delimiter from '.' to '_'
      // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
      elemName = elemName.replace(/\./g, pathDelimiter);
      let assocName = originalAssocName.replace(/\./g, pathDelimiter);
      // clone the onCond for later use in the path transformation,
      // also assign the _artifact elements of the path elements to the copy
      let newOnCond = cloneWithTransformations(assoc.on, {
        ref: (value, node, resultNode) => {
          resultNode = cloneWithTransformations(value, {});
          return resultNode;
        }
      });
      // goes through the the newOnCond and transform all the 'path' elements
      forEachRef(newOnCond, (ref) => {
        if (ref[0] === assocName) // we are in the "path" from the forwarding assoc => need to remove the first part of the path
          ref.shift();
        else { // we are in the backlink assoc "path" => need to push at the beginning the association's id
          ref.unshift(elemName);
          // if there was a $self identifier in the forwarding association onCond
          // we do not need it any more, as we prepended in the previous step the back association's id
          if (ref[1] === '$self')
            ref.splice(1, 1);
        }
      });
      return newOnCond;
    }
  }

  // Replace (formerly) managed associations in GROUP BY and ORDER BY of 'view' by their foreign key fields.
  // FIXME: We should also complain about unmanaged assocs?
  // FIXME: We should also check for structured entries for 'keepStructsAssocs'
  function replaceAssociationsInGroupByOrderBy(view, viewName) {
    if(view.query){
      forAllQueries(view.query, (q, p) => replaceAssocsInGroupOrder(q, p), ['definitions', viewName, 'query']);
    }
    
    function replaceAssocsInGroupOrder(inputQuery, path){
      const query = inputQuery.SET || inputQuery.SELECT;

      if(query.groupBy){
        const newGroupBy = [];
        for(let i = 0; i < query.groupBy.length; i++){
          const groupByPath = path.concat(['groupBy', i]);
          if(query.groupBy[i].ref){
            const  { art } = inspectRef(groupByPath);
            if(art.target){
              // This is (or used to be before transformation) a managed assoc
              // (230 c) If we keep associations as they are (hdbcds naming convention), we can't have associations in GROUP BY
              if (options.forHana.keepStructsAssocs) {
                signal(error`With "hdbcds" naming, managed association elements cannot be used in the GROUP BY clause of a view`, groupByPath);
                continue;
              }
              const pathPrefix = query.groupBy[i].ref.slice(0,-1);
              getForeignKeyRefs(art)
                .map(fk => {
                  return {ref: pathPrefix.concat(fk.ref)}
                })
                .forEach(fk => newGroupBy.push(fk));
            } else {
              newGroupBy.push(query.groupBy[i]);
            }
          } else {
            newGroupBy.push(query.groupBy[i]);
          }
        }
        query.groupBy = newGroupBy;
      }

      if(query.orderBy){
        const newOrderBy = [];
        for(let i = 0; i < query.orderBy.length; i++){
          const orderByPath = path.concat(['orderBy', i]);
          if(query.orderBy[i].ref){
            const  { art } = inspectRef(orderByPath);
            if(art.target){
            // This is (or used to be before transformation) a managed assoc
            // (230 d) If we keep associations as they are (hdbcds naming convention), we can't have associations in ORDER BY
              if (options.forHana.keepStructsAssocs) {
                signal(error`With "hdbcds" naming, managed association elements cannot be used in the ORDER BY clause of a view`, orderByPath);
                continue;
              }
              const pathPrefix = query.orderBy[i].ref.slice(0,-1);
              getForeignKeyRefs(art)
                .map(fk => {
                  return {ref: pathPrefix.concat(fk.ref)}
                })
                .forEach(fk => newOrderBy.push(fk));            
            } else {
              newOrderBy.push(query.orderBy[i]);
            }
          } else {
            newOrderBy.push(query.orderBy[i]);
          }
        }
        query.orderBy = newOrderBy;
      }
    }
    function getForeignKeyRefs(assoc){
      return assoc.keys.map(fk => { 
        return {ref: [fk.$generatedFieldName] }
      });
    }
  }

  // Collect all artifacts that are transitively reachable via compositions from 'artifact' into 'draftNodes'.
  // 'rootArtifact' is the root artifact where composition traversal started.
  // Check that no artifact other than the root node has '@odata.draft.enabled'
  function collectDraftNodesInto(artifact, rootArtifact, draftNodes) {
    // Collect the artifact itself
    draftNodes[artifact.name.absolute] = artifact;
    // Follow all composition targets in elements of 'artifact'
    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      if (elem.target && elem._finalType.type._artifact.name.absolute == 'cds.Composition') {
        let draftNode = elem.target._artifact;
        // Sanity check
        if (!draftNode) {
          throw new Error('Expecting target to be resolved: ' + JSON.stringify(elem, null, 2));
        }
        // Ignore composition if not part of a service
        if (!draftNode._service) {
          signal(warning`Target "${draftNode.name.absolute}" of composition "${elem.name.absolute}.${elem.name.element}" cannot be a draft node because it is not part of a service`, elem.location);
          continue;
        }
        // Barf if a draft node other than the root has @odata.draft.enabled itself
        if (draftNode != rootArtifact && hasBoolAnnotation(draftNode, '@odata.draft.enabled')) {
          signal(error`"${elem.name.absolute}.${elem.name.element}": Composition in draft-enabled entity cannot lead to another entity with "@odata.draft.enabled"`, elem.location);
          delete draftNodes[draftNode.name.absolute];
          continue;
        }
        // Recurse unless already known
        if (!draftNodes[draftNode.name.absolute]) {
          collectDraftNodesInto(draftNode, rootArtifact, draftNodes);
        }
      }
    }
  }

  // Generate all that is required in HANA CDS for draft enablement of 'artifact'.
  function generateDraftForHana(artifact) {
    // console.error(`generateDraftForHana(${artifact.name.absolute})`);
    // Sanity check
    if (!artifact._service) {
      throw new Error('Expecting artifact to be part of a service: ' + JSON.stringify(artifact));
    }

    // The name of the draft shadow entity we should generate
    let draftsArtifactName = artifact.name.absolute + '_drafts';

    // FIXME: Current restriction: Must only have exactly one key, which is of type UUID
    let keyNames = Object.keys(artifact.elements).filter(elemName => {
      return artifact.elements[elemName].key && artifact.elements[elemName].key.val;
    });
    if (keyNames.length != 1) {
      signal(warning`"${artifact.name.absolute}": Ignoring annotation "@odata.draft.enabled" - currently only supported for artifacts with exactly one key of type "UUID"`, artifact.location);
      return;
    }
    let keyElem = artifact.elements[keyNames[0]];
    // Sanity check
    if (!keyElem._finalType) {
      throw new Error('Expecting artifact to have final type: ' + JSON.stringify(keyElem));
    }
    if (keyElem._finalType.name.absolute != 'cds.UUID' && keyElem._finalType.name.$renamed != 'cds.UUID') {
      signal(warning`"${artifact.name.absolute}": Ignoring annotation "@odata.draft.enabled" - currently only supported for key of type "UUID"`, keyElem.location);
      return;
    }

    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    let draftAdminDataProjectionName = artifact._service.name.absolute + '.' + 'DraftAdministrativeData';
    let draftAdminDataProjection = csn.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(artifact._service);
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind != 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      signal(error`Generated entity "${draftAdminDataProjectionName}" conflicts with existing artifact`, draftAdminDataProjection.location);
    }

    // Duplicate the artifact as a draft shadow entity
    if (csn.definitions[draftsArtifactName]) {
      signal(error`"${draftsArtifactName}": Generated entity name conflicts with existing entity`, csn.definitions[draftsArtifactName].location);
      return;
    }
    let draftsArtifact = {
      name: {
        path: [{
          id: draftsArtifactName
        },],
        id: artifact.name.id + '_drafts',
        absolute: draftsArtifactName,
      },
      kind: 'entity',
      elements: Object.create(null),
    };
    setProp(draftsArtifact, '_service', artifact._service);
    setProp(draftsArtifact, '_finalType', draftsArtifact);
    // Copy all elements
    for (let elemName in artifact.elements) {
      let elem = copyAndAddElement(artifact.elements[elemName], draftsArtifact, elemName);
      // explicitly set nullable if not key and not unmanaged association
      if ((!elem.key || !elem.key.val) && !elem.onCond) {
        elem.notNull = {
          val: false,
        }
      }
    }

    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    let isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', false);
    addElement(isActiveEntity, draftsArtifact);

    // HasActiveEntity : Boolean default false
    let hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false);
    addElement(hasActiveEntity, draftsArtifact);

    // HasDraftEntity : Boolean default false;
    let hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false);
    addElement(hasDraftEntity, draftsArtifact);

    // DraftAdministrativeData : Association to one DraftAdministrativeData not null;
    let draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjection, true);
    draftAdministrativeData.cardinality = {
      targetMax: {
        literal: 'number',
        val: 1,
      },
    };
    draftAdministrativeData.notNull = {
      val: true,
    }
    addElement(draftAdministrativeData, draftsArtifact);
    // Note that we may need to do the HANA transformation steps for managed associations
    // (foreign key field generation, generatedFieldName, creating ON-condition) by hand,
    // because the corresponding transformation steps have already been done on all artifacts
    // when we come here). Only for 'keepStructsAssocs' this is not required.
    if (!options.forHana.keepStructsAssocs && draftAdministrativeData.foreignKeys['DraftUUID']) {
      createForeignKeyElement(draftAdministrativeData, draftAdministrativeData.foreignKeys['DraftUUID'], draftsArtifact);
      draftAdministrativeData.onCond = createAssociationPathComparison(draftAdministrativeData,
        draftAdminDataProjection.elements['DraftUUID'],
        '=',
        draftsArtifact.elements['DraftAdministrativeData' + pathDelimiter + 'DraftUUID']);
      // The notNull has been transferred to the foreign key field and must be removed on the association
      delete draftAdministrativeData.notNull;

      // The association is now unmanaged, i.e. actually it should no longer have foreign keys
      // at all. But the processing of backlink associations below expects to have them, so
      // we don't delete them (but mark them as implicit so that toCdl does not render them)
      draftAdministrativeData.implicitForeignKeys = true;
    }

    // Add draft shadow entity to the csn
    csn.definitions[draftsArtifactName] = draftsArtifact;
  }

  // Redirect all association/composition targets in 'artifact' that point to targets in
  // the dictionary 'draftNodes' to their corresponding draft shadow artifacts.
  function redirectDraftTargets(artifact, draftNodes) {
    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      if (elem.target) {
        let target = elem.target._artifact;
        // Sanity check
        if (!target) {
          throw new Error('Expecting target to be resolved: ' + JSON.stringify(elem, null, 2));
        }
        // Nothing to do if target is not a draft node
        if (!draftNodes[target.name.absolute]) {
          continue;
        }
        // Redirect the composition/association in this draft shadow entity to the target draft shadow entity
        // console.error(`Redirecting target of ${elemName} in ${artifact.name.absolute} to ${target.name.absolute + '_drafts'}`);
        let shadowTarget = getDraftShadowEntityFor(target);
        // Might not exist because of previous errors
        if (shadowTarget) {
          elem.target.path[elem.target.path.length - 1].id = shadowTarget.name.id;
          setProp(elem.target.path[elem.target.path.length - 1], '_artifact', shadowTarget);
          setProp(elem.target, '_artifact', shadowTarget);
          // FIXME: Strictly speaking, we would also need to replace the foreign keys' _artifact links,
          // but since their content is identical anyway, we simply omit that for now.
        }
      }
    }

    // Returns the corresponding draft shadow artifact for draft node 'draftNode'.
    function getDraftShadowEntityFor(draftNode) {
      // Sanity check
      if (!draftNodes[draftNode.name.absolute]) {
        throw new Error(`Not a draft node: ${draftNode.name.absolute}`);
      }
      return csn.definitions[draftNode.name.absolute + '_drafts'];
    }
  }

  /**
   * Check if the given element of the given element uses 'array of'.
   *
   * It checks the element itself and any types used or "subelements".
   *
   * @param {any} artifact The artifact
   * @param {any} element The element to check
   * @returns {undefined}
   */
  /* Old implementation:
function checkForArrayOf(artifact, element) {
function show_error(eltName) {
  signal(error`"${artifact.name.absolute}.${eltName}": Array types are not allowed as table types`, element.location);
}

function check(e, current_path, skip_name = false) {
  // Only append element names to the path, skip names for typeof, since those take the following route:
  // a: x; b: typeof a; b -> a -> x. We only want to log b -> x
  if (e.name.element && !skip_name) {
    if (!current_path) {
      current_path = e.name.id;
    } else {
      current_path += '.' + e.name.id;
    }
  }

  // E is undefined -> return. Should not happen, just in case.
  if (!e) return;
  else if (e.$inferred) return;
  // Element has items -> This means it is an array of, show error and return.
  else if (e.items) show_error(current_path);
  // Element has elements -> Check each sub-element.
  else if (e.elements) {
    for (let innerElement of Object.keys(e.elements)) {
      check(e.elements[innerElement], current_path);
    }
  }
  // Element has a type -> Check if the type is/contains an array
  else if (e.type && !e.type.$inferred && e.type._artifact && (!e.type._artifact.builtin || e.type._artifact.builtin !== true)) {
    check(e.type._artifact, current_path, e.type.absolute === artifact.name.absolute); // skip names for typeOf
  }
  else return;
}
// Start the recursive checking (if table is really about to be created)
// FIXME: same expression as in checkElements => utility function?
const createTable =
  !(artifact.abstract || (artifact['@cds.persistence.skip'] && artifact['@cds.persistence.skip'].val !== null && artifact['@cds.persistence.skip'].val !== false) ||
    (artifact['@cds.persistence.exists'] && artifact['@cds.persistence.exists'].val !== null && artifact['@cds.persistence.exists'].val !== false));

if (createTable)
  check(element);
}
*/
  function checkForArrayOf(artifact, artifactName, element, elementName) {
    /**
     * Show the error message for the given element name
     *
     * @param {any} eltName Name of the element
     * @returns {undefined}
     */
    function show_error(eltName) {
      signal(error`"${artifactName}.${eltName}": Array types are not allowed as table types`, ["definitions", artifactName, "elements", eltName ]);
    }

    /**
     * Recursively check the if the given element contains array of
     * and is really going to the database (no @cds.persistence.skip/exists: true)
     * @param {any} e Element to check
     * @param {any} current_path Current path for better error messages
     * @returns {undefined}
     */
    function check(e, eName, current_path, skip_name = false) {
      // Only append element names to the path, skip names for typeof, since those take the following route:
      // a: x; b: typeof a; b -> a -> x. We only want to log b -> x
      if (eName && !skip_name) {
        if (!current_path) {
          current_path = eName;
        } else {
          current_path += '.' + eName;
        }
      }

      // E is undefined -> return. Should not happen, just in case.
      if (!e) return;
      // Element has items -> This means it is an array of, show error and return.
      else if (e.items) show_error(current_path);
      // Element has elements -> Check each sub-element.
      else if (e.elements) {
        for (let innerElement of Object.keys(e.elements)) {
          check(e.elements[innerElement], innerElement, current_path);
        }
      }
      // Element has a type -> Check if the type is/contains an array
      else if (e.type) {
        // Don't check built-ins
        if (isBuiltinType(e.type)) {
          return;
        } else {
          check(csn.definitions[e.type], e.type, current_path);
        }
      } else return;
    }
    // Start the recursive checking (if table is really about to be created)
    // FIXME: same expression as in checkElements => utility function?
    const createTable = !(artifact.abstract || (artifact['@cds.persistence.skip'] && artifact['@cds.persistence.skip'] !== null && artifact['@cds.persistence.skip'] !== false) ||
      (artifact['@cds.persistence.exists'] && artifact['@cds.persistence.exists'] !== null && artifact['@cds.persistence.exists'] !== false));

    if (createTable)
      check(element, elementName);
  }

  // TODO: XSN - Implementation most likely to naive, can we rely on query.SELECT.mixin?
  function checkIsNotMixinByItself(query, element, elementName) {
    if (query && query.SELECT && query.SELECT.mixin) {
      // If the element is not part of the mixin => True
      return query.SELECT.mixin[elementName] == undefined;
    } else {
      // the artifact does not define any mixins, the element cannot be a mixin
      return true;
    }
  }

  function getAliasName(refArray, path) {
    if(!refArray){
      return undefined;
    }
    const { art } = inspectRef(path);
    let alias = refArray[0];
    if(art && art.kind === 'entity'){
      // Last ref points to another entity - use that as "from"-ref
      alias = refArray[refArray.length - 1];
    } 
    return alias.substring(alias.lastIndexOf('.') + 1) || alias;
  }
  
  function insideColumns(path) {
    return path.length >=3 && path[path.length-3] === 'SELECT' &&  path[path.length-2] === 'columns';
  }

  /**
   * Check the given query for:
   * - Associations-traversal over skipped/abstract things
   * 
   * Currently checked:
   * - "columns" for something like toF.id, where F is skipped. But publishing toF is fine, will be ignored later on
   * - "from" for something like "select from E.toF" where E, F or E AND F are no-db.
   * 
   * @param {any} query Query to check
   * @param {any} path Path to the current query
   */
  function checkQueryForNoDBArtifacts(query, path){
    const generalQueryProperties = ['from', 'columns'];
    for(const prop of generalQueryProperties){
      const queryPart = query[prop];
      if(Array.isArray(queryPart)){
        for(let i = 0; i < queryPart.length; i++){
          const part = queryPart[i];
          checkRef(part, path.concat([prop, i]), prop === 'from');
        }
      } else if(typeof queryPart == 'object') {
        checkRef(queryPart, path.concat([prop]), prop === 'from');
      }
    }
    
    function checkRef(obj, path, inFrom){
      if(!(obj && obj.ref)){
        return;
      }

      const { links, scope } = inspectRef(path);
      if(!links || scope === 'alias'){
        return;
      }
      // Don't check the last element - to allow association publishing in columns
      for(let i = 0; i < (inFrom ? links.length : links.length-1); i++){
        const link = links[i];
        if(!link){
          continue;
        }
        const { art } = link; 
        if(!art){
          continue;
        }
        const endArtifact = art.target ? getCsnDef(art.target) : art;
        const name = art.target ? art.target : obj.ref[i];
        if(isNoDbArtifact(endArtifact)){
          signal(error`"${path[1]}": "${name}" in path step "${obj.ref[i]}" of "${obj.ref.join('.')}" is either 'abstract' or '@cds.persistence.skip'`, path);
        }
      }
    }
  }
}

module.exports = {
  transformForHanaWithCsn
};
